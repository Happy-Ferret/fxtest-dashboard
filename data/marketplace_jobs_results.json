{"last_updated": "2014-08-06 10:30:01.979408", "results": [{"group": "Android", "test_results": [{"skipped": {}, "all_passed": true, "environments": ["dev", "prod", "stage"], "path_to_result": "tests.mobile.test_reviews/TestReviews/test_that_after_viewing_reviews_clicking_back_goes_to_app_page/", "failed": [], "passed": ["marketplace.dev.mobile.saucelabs", "marketplace.prod.mobile.saucelabs", "marketplace.stage.mobile.saucelabs"], "test_name": "test_that_after_viewing_reviews_clicking_back_goes_to_app_page"}, {"skipped": {}, "all_passed": true, "environments": ["dev", "prod", "stage"], "path_to_result": "tests.mobile.test_search/TestSearch/test_searching_with_no_matching_results/", "failed": [], "passed": ["marketplace.dev.mobile.saucelabs", "marketplace.prod.mobile.saucelabs", "marketplace.stage.mobile.saucelabs"], "test_name": "test_searching_with_no_matching_results"}, {"skipped": {"jobs": ["marketplace.dev.mobile.saucelabs", "marketplace.stage.mobile.saucelabs"], "result": "skipped", "detail": "expected test failure: Issue 500 Login tests currently don't work on Saucelabs"}, "all_passed": true, "environments": ["dev", "stage"], "path_to_result": "tests.mobile.test_reviews/TestReviews/test_that_checks_the_addition_of_a_review/", "failed": [], "passed": [], "test_name": "test_that_checks_the_addition_of_a_review"}, {"skipped": {"jobs": ["marketplace.dev.mobile.saucelabs", "marketplace.prod.mobile.saucelabs", "marketplace.stage.mobile.saucelabs"], "result": "skipped", "detail": "expected test failure: Issue 500 Login tests currently don't work on Saucelabs"}, "all_passed": true, "environments": ["dev", "prod", "stage"], "path_to_result": "tests.mobile.test_users_account/TestAccounts/test_user_can_go_back_from_settings_page/", "failed": [], "passed": [], "test_name": "test_user_can_go_back_from_settings_page"}, {"skipped": {}, "all_passed": true, "environments": ["dev", "prod", "stage"], "path_to_result": "tests.mobile.test_home_page/TestHomepage/test_that_verifies_categories_section/", "failed": [], "passed": ["marketplace.dev.mobile.saucelabs", "marketplace.prod.mobile.saucelabs", "marketplace.stage.mobile.saucelabs"], "test_name": "test_that_verifies_categories_section"}, {"skipped": {}, "all_passed": true, "environments": ["dev", "prod", "stage"], "path_to_result": "tests.mobile.test_search/TestSearch/test_that_searching_returns_results/", "failed": [], "passed": ["marketplace.dev.mobile.saucelabs", "marketplace.prod.mobile.saucelabs", "marketplace.stage.mobile.saucelabs"], "test_name": "test_that_searching_returns_results"}, {"skipped": {}, "all_passed": true, "environments": ["dev", "prod", "stage"], "path_to_result": "tests.mobile.test_details_page/TestDetails/test_details_page_for_an_app/", "failed": [], "passed": ["marketplace.dev.mobile.saucelabs", "marketplace.prod.mobile.saucelabs", "marketplace.stage.mobile.saucelabs"], "test_name": "test_details_page_for_an_app"}, {"skipped": {"jobs": ["marketplace.dev.mobile.saucelabs", "marketplace.prod.mobile.saucelabs", "marketplace.stage.mobile.saucelabs"], "result": "skipped", "detail": "expected test failure: Issue 500 Login tests currently don't work on Saucelabs"}, "all_passed": true, "environments": ["dev", "prod", "stage"], "path_to_result": "tests.mobile.test_users_account/TestAccounts/test_user_can_login_and_logout/", "failed": [], "passed": [], "test_name": "test_user_can_login_and_logout"}, {"skipped": {"jobs": ["marketplace.dev.mobile.saucelabs", "marketplace.stage.mobile.saucelabs"], "result": "skipped", "detail": "expected test failure: Issue 500 Login tests currently don't work on Saucelabs"}, "all_passed": true, "environments": ["dev", "stage"], "path_to_result": "tests.mobile.test_reviews/TestReviews/test_that_after_writing_a_review_clicking_back_goes_to_app_page/", "failed": [], "passed": [], "test_name": "test_that_after_writing_a_review_clicking_back_goes_to_app_page"}, {"skipped": {}, "all_passed": true, "environments": ["dev", "prod", "stage"], "path_to_result": "tests.mobile.test_search/TestSearch/test_that_searching_with_empty_field_returns_results/", "failed": [], "passed": ["marketplace.dev.mobile.saucelabs", "marketplace.prod.mobile.saucelabs", "marketplace.stage.mobile.saucelabs"], "test_name": "test_that_searching_with_empty_field_returns_results"}, {"skipped": {}, "all_passed": true, "environments": ["dev", "prod", "stage"], "path_to_result": "tests.mobile.test_details_page/TestDetails/test_reviews_section/", "failed": [], "passed": ["marketplace.dev.mobile.saucelabs", "marketplace.prod.mobile.saucelabs", "marketplace.stage.mobile.saucelabs"], "test_name": "test_reviews_section"}, {"skipped": {}, "all_passed": true, "environments": ["dev", "prod", "stage"], "path_to_result": "tests.mobile.test_home_page/TestHomepage/test_switch_between_new_and_popular_tab/", "failed": [], "passed": ["marketplace.dev.mobile.saucelabs", "marketplace.prod.mobile.saucelabs", "marketplace.stage.mobile.saucelabs"], "test_name": "test_switch_between_new_and_popular_tab"}, {"skipped": {"jobs": ["marketplace.dev.mobile.saucelabs", "marketplace.prod.mobile.saucelabs", "marketplace.stage.mobile.saucelabs"], "result": "skipped", "detail": "condition: True: /Users/Shared/Jenkins/Home/jobs/marketplace.dev.mobile.saucelabs/workspace/.env/lib/python2.7/site-packages/_pytest/skipping.py:120: Skipped: condition: True"}, "all_passed": true, "environments": ["dev", "prod", "stage"], "path_to_result": "tests.mobile.test_search/TestSearch/test_that_verifies_the_search_suggestions_list_under_the_search_field/", "failed": [], "passed": [], "test_name": "test_that_verifies_the_search_suggestions_list_under_the_search_field"}]}, {"group": "Firefox OS", "test_results": [{"skipped": {}, "all_passed": false, "environments": ["unknown"], "path_to_result": "test_marketplace_add_review/TestMarketplaceAddReview/test_add_review/", "failed": [{"jobs": ["b2g.hamachi.mozilla-b2g28_v1_3.v1.3.marketplace"], "result": "error", "detail": "test error: Traceback (most recent call last):\n  File \"/var/jenkins/workspace/b2g.hamachi.mozilla-b2g28_v1_3.v1.3.marketplace/.env/local/lib/python2.7/site-packages/marionette_client_mozilla_b2g28_v1_3-0.2-py2.7.egg/marionette/marionette_test.py\", line 163, in run\n    testMethod()\n  File \"/var/jenkins/workspace/b2g.hamachi.mozilla-b2g28_v1_3.v1.3.marketplace/marketplacetests/tests/test_marketplace_add_review.py\", line 19, in test_add_review\n    env={\"browserid\": \"firefoxos.persona.org\", \"verifier\": \"marketplace-dev.allizom.org\"})\n  File \"/var/jenkins/workspace/b2g.hamachi.mozilla-b2g28_v1_3.v1.3.marketplace/.env/local/lib/python2.7/site-packages/gaiatest_v1.3-0.2-py2.7.egg/gaiatest/mocks/persona_test_user.py\", line 53, in create_user\n    raise Exception(\"Could not get Persona user from personatestuser.org: %s\" % e.reason)\nException: Could not get Persona user from personatestuser.org: [Errno -2] Name or service not known"}], "passed": [], "test_name": "test_add_review"}, {"skipped": {"jobs": ["b2g.hamachi.mozilla-b2g28_v1_3.v1.3.marketplace"], "result": "skipped", "detail": "test skipped: Traceback (most recent call last):\n  File \"/var/jenkins/workspace/b2g.hamachi.mozilla-b2g28_v1_3.v1.3.marketplace/.env/local/lib/python2.7/site-packages/marionette_client_mozilla_b2g28_v1_3-0.2-py2.7.egg/marionette/marionette_test.py\", line 158, in run\n    testMethod()\n  File \"/var/jenkins/workspace/b2g.hamachi.mozilla-b2g28_v1_3.v1.3.marketplace/marketplacetests/tests/test_marketplace_search_and_install_app.py\", line 47, in test_search_and_install_app\n    self.assertEqual('%s installed' % self.app_name, marketplace.install_notification_message)\nAssertionError: u'ConnectA2 installed' != u'ConnectA2 download stopped'\n- ConnectA2 installed\n+ ConnectA2 download stopped\n"}, "all_passed": true, "environments": ["unknown"], "path_to_result": "test_marketplace_search_and_install_app/TestSearchMarketplaceAndInstallApp/test_search_and_install_app/", "failed": [], "passed": [], "test_name": "test_search_and_install_app"}, {"skipped": {}, "all_passed": false, "environments": ["unknown"], "path_to_result": "test_marketplace_feedback_login/TestMarketplaceFeedback/test_marketplace_feedback_user/", "failed": [{"jobs": ["b2g.hamachi.mozilla-b2g28_v1_3.v1.3.marketplace"], "result": "error", "detail": "test error: Traceback (most recent call last):\n  File \"/var/jenkins/workspace/b2g.hamachi.mozilla-b2g28_v1_3.v1.3.marketplace/.env/local/lib/python2.7/site-packages/marionette_client_mozilla_b2g28_v1_3-0.2-py2.7.egg/marionette/marionette_test.py\", line 163, in run\n    testMethod()\n  File \"/var/jenkins/workspace/b2g.hamachi.mozilla-b2g28_v1_3.v1.3.marketplace/marketplacetests/tests/test_marketplace_feedback_login.py\", line 20, in test_marketplace_feedback_user\n    env={\"browserid\": \"firefoxos.persona.org\", \"verifier\": \"marketplace-dev.allizom.org\"})\n  File \"/var/jenkins/workspace/b2g.hamachi.mozilla-b2g28_v1_3.v1.3.marketplace/.env/local/lib/python2.7/site-packages/gaiatest_v1.3-0.2-py2.7.egg/gaiatest/mocks/persona_test_user.py\", line 53, in create_user\n    raise Exception(\"Could not get Persona user from personatestuser.org: %s\" % e.reason)\nException: Could not get Persona user from personatestuser.org: [Errno -2] Name or service not known"}], "passed": [], "test_name": "test_marketplace_feedback_user"}, {"skipped": {}, "all_passed": true, "environments": ["unknown"], "path_to_result": "test_marketplace_feedback_anonymous/TestMarketplaceFeedback/test_marketplace_feedback_anonymous/", "failed": [], "passed": ["b2g.hamachi.mozilla-b2g28_v1_3.v1.3.marketplace"], "test_name": "test_marketplace_feedback_anonymous"}, {"skipped": {}, "all_passed": false, "environments": ["unknown"], "path_to_result": "test_marketplace_login/TestMarketplaceLogin/test_login_marketplace/", "failed": [{"jobs": ["b2g.hamachi.mozilla-b2g28_v1_3.v1.3.marketplace"], "result": "error", "detail": "test error: Traceback (most recent call last):\n  File \"/var/jenkins/workspace/b2g.hamachi.mozilla-b2g28_v1_3.v1.3.marketplace/.env/local/lib/python2.7/site-packages/marionette_client_mozilla_b2g28_v1_3-0.2-py2.7.egg/marionette/marionette_test.py\", line 145, in run\n    self.setUp()\n  File \"/var/jenkins/workspace/b2g.hamachi.mozilla-b2g28_v1_3.v1.3.marketplace/marketplacetests/tests/test_marketplace_login.py\", line 17, in setUp\n    env={\"browserid\": \"firefoxos.persona.org\", \"verifier\": \"marketplace-dev.allizom.org\"})\n  File \"/var/jenkins/workspace/b2g.hamachi.mozilla-b2g28_v1_3.v1.3.marketplace/.env/local/lib/python2.7/site-packages/gaiatest_v1.3-0.2-py2.7.egg/gaiatest/mocks/persona_test_user.py\", line 53, in create_user\n    raise Exception(\"Could not get Persona user from personatestuser.org: %s\" % e.reason)\nException: Could not get Persona user from personatestuser.org: [Errno -2] Name or service not known"}], "passed": [], "test_name": "test_login_marketplace"}, {"skipped": {}, "all_passed": true, "environments": ["unknown"], "path_to_result": "test_marketplace_without_connectivity/TestMarketplaceWithoutConnectivity/test_marketplace_without_connectivity/", "failed": [], "passed": ["b2g.hamachi.mozilla-b2g28_v1_3.v1.3.marketplace"], "test_name": "test_marketplace_without_connectivity"}, {"skipped": {"jobs": ["b2g.hamachi.mozilla-b2g28_v1_3.v1.3.marketplace"], "result": "skipped", "detail": "test skipped: Traceback (most recent call last):\n  File \"/var/jenkins/workspace/b2g.hamachi.mozilla-b2g28_v1_3.v1.3.marketplace/.env/local/lib/python2.7/site-packages/marionette_client_mozilla_b2g28_v1_3-0.2-py2.7.egg/marionette/marionette_test.py\", line 158, in run\n    testMethod()\n  File \"/var/jenkins/workspace/b2g.hamachi.mozilla-b2g28_v1_3.v1.3.marketplace/marketplacetests/tests/test_marketplace_purchase_app.py\", line 24, in test_purchase_app\n    \"verifier\": \"marketplace-dev.allizom.org\"})\n  File \"/var/jenkins/workspace/b2g.hamachi.mozilla-b2g28_v1_3.v1.3.marketplace/.env/local/lib/python2.7/site-packages/gaiatest_v1.3-0.2-py2.7.egg/gaiatest/mocks/persona_test_user.py\", line 53, in create_user\n    raise Exception(\"Could not get Persona user from personatestuser.org: %s\" % e.reason)\nException: Could not get Persona user from personatestuser.org: [Errno -2] Name or service not known"}, "all_passed": true, "environments": ["unknown"], "path_to_result": "test_marketplace_purchase_app/TestMarketplacePurchaseApp/test_purchase_app/", "failed": [], "passed": [], "test_name": "test_purchase_app"}, {"skipped": {"jobs": ["b2g.hamachi.mozilla-b2g28_v1_3.v1.3.marketplace"], "result": "skipped", "detail": "test skipped: Traceback (most recent call last):\n  File \"/var/jenkins/workspace/b2g.hamachi.mozilla-b2g28_v1_3.v1.3.marketplace/.env/local/lib/python2.7/site-packages/marionette_client_mozilla_b2g28_v1_3-0.2-py2.7.egg/marionette/marionette_test.py\", line 158, in run\n    testMethod()\n  File \"/var/jenkins/workspace/b2g.hamachi.mozilla-b2g28_v1_3.v1.3.marketplace/marketplacetests/tests/test_marketplace_search_for_paid_app.py\", line 35, in test_search_paid_app\n    self.fail('The app: %s was not found.' % APP_NAME)\nAssertionError: The app: Test Zippy With Me was not found."}, "all_passed": true, "environments": ["unknown"], "path_to_result": "test_marketplace_search_for_paid_app/TestSearchMarketplacePaidApp/test_search_paid_app/", "failed": [], "passed": [], "test_name": "test_search_paid_app"}, {"skipped": {"jobs": ["b2g.hamachi.mozilla-b2g28_v1_3.v1.3.marketplace"], "result": "skipped", "detail": "test skipped: Traceback (most recent call last):\n  File \"/var/jenkins/workspace/b2g.hamachi.mozilla-b2g28_v1_3.v1.3.marketplace/.env/local/lib/python2.7/site-packages/marionette_client_mozilla_b2g28_v1_3-0.2-py2.7.egg/marionette/marionette_test.py\", line 158, in run\n    testMethod()\n  File \"/var/jenkins/workspace/b2g.hamachi.mozilla-b2g28_v1_3.v1.3.marketplace/marketplacetests/tests/test_marketplace_create_confirm_pin.py\", line 23, in test_create_confirm_pin\n    \"verifier\": \"marketplace-dev.allizom.org\"})\n  File \"/var/jenkins/workspace/b2g.hamachi.mozilla-b2g28_v1_3.v1.3.marketplace/.env/local/lib/python2.7/site-packages/gaiatest_v1.3-0.2-py2.7.egg/gaiatest/mocks/persona_test_user.py\", line 53, in create_user\n    raise Exception(\"Could not get Persona user from personatestuser.org: %s\" % e.reason)\nException: Could not get Persona user from personatestuser.org: [Errno -2] Name or service not known"}, "all_passed": true, "environments": ["unknown"], "path_to_result": "test_marketplace_create_confirm_pin/TestMarketplaceCreateConfirmPin/test_create_confirm_pin/", "failed": [], "passed": [], "test_name": "test_create_confirm_pin"}]}, {"group": "Desktop", "test_results": [{"skipped": {}, "all_passed": true, "environments": ["dev", "prod", "stage"], "path_to_result": "tests.desktop.consumer_pages.test_details_page/TestDetailsPage/test_that_application_page_contains_proper_objects/", "failed": [], "passed": ["marketplace.dev.saucelabs", "marketplace.prod", "marketplace.stage.saucelabs", "marketplace.prod.saucelabs"], "test_name": "test_that_application_page_contains_proper_objects"}, {"skipped": {}, "all_passed": true, "environments": ["dev", "prod", "stage"], "path_to_result": "tests.desktop.consumer_pages.test_search/TestSearching/test_that_the_search_tag_is_present_in_the_search_results/", "failed": [], "passed": ["marketplace.dev.saucelabs", "marketplace.prod", "marketplace.stage.saucelabs", "marketplace.prod.saucelabs"], "test_name": "test_that_the_search_tag_is_present_in_the_search_results"}, {"skipped": {}, "all_passed": true, "environments": ["stage", "dev"], "path_to_result": "tests.desktop.developer_hub.test_developer_hub/TestDeveloperHub/test_that_checks_apps_are_sorted_by_date/", "failed": [], "passed": ["marketplace.stage.developer_hub.saucelabs", "marketplace.dev.developer_hub", "marketplace.dev.developer_hub.saucelabs"], "test_name": "test_that_checks_apps_are_sorted_by_date"}, {"skipped": {}, "all_passed": true, "environments": ["dev", "prod", "stage"], "path_to_result": "tests.desktop.consumer_pages.test_consumers_page/TestConsumerPage/test_open_view_all_link_while_popular_tab_selected/", "failed": [], "passed": ["marketplace.dev.saucelabs", "marketplace.prod", "marketplace.stage.saucelabs", "marketplace.prod.saucelabs"], "test_name": "test_open_view_all_link_while_popular_tab_selected"}, {"skipped": {}, "all_passed": true, "environments": ["dev", "prod", "stage"], "path_to_result": "tests.desktop.consumer_pages.test_consumers_page/TestConsumerPage/test_that_clicking_on_featured_app_loads_details_page/", "failed": [], "passed": ["marketplace.dev.saucelabs", "marketplace.prod", "marketplace.stage.saucelabs", "marketplace.prod.saucelabs"], "test_name": "test_that_clicking_on_featured_app_loads_details_page"}, {"skipped": {}, "all_passed": true, "environments": ["stage", "dev"], "path_to_result": "tests.desktop.developer_hub.test_developer_hub/TestDeveloperHub/test_that_checks_editing_basic_info_for_a_free_app/", "failed": [], "passed": ["marketplace.stage.developer_hub.saucelabs", "marketplace.dev.developer_hub", "marketplace.dev.developer_hub.saucelabs"], "test_name": "test_that_checks_editing_basic_info_for_a_free_app"}, {"skipped": {"jobs": ["marketplace.dev.saucelabs", "marketplace.stage.saucelabs"], "result": "skipped", "detail": "We currently don't have the option for changing the language in Fireplace: /Users/Shared/Jenkins/Home/jobs/marketplace.dev.saucelabs/workspace/tests/desktop/consumer_pages/test_users_account.py:76: Skipped: We currently don't have the option for changing the language in Fireplace"}, "all_passed": true, "environments": ["dev", "stage"], "path_to_result": "tests.desktop.consumer_pages.test_users_account/TestAccounts/test_that_checks_changing_language/", "failed": [], "passed": [], "test_name": "test_that_checks_changing_language"}, {"skipped": {}, "all_passed": true, "environments": ["stage", "dev"], "path_to_result": "tests.desktop.developer_hub.test_developer_hub_submit_apps/TestDeveloperHubSubmitApps/test_hosted_app_submission/", "failed": [], "passed": ["marketplace.stage.developer_hub.saucelabs", "marketplace.dev.developer_hub", "marketplace.dev.developer_hub.saucelabs"], "test_name": "test_hosted_app_submission"}, {"skipped": {}, "all_passed": false, "environments": ["dev", "stage"], "path_to_result": "tests.desktop.consumer_pages.test_users_account/TestAccounts/test_editing_user_profile/", "failed": [{"jobs": ["marketplace.dev.saucelabs"], "result": "failure", "detail": "test failure: self = <tests.desktop.consumer_pages.test_users_account.TestAccounts instance at 0x103450908>\nmozwebqa = <pytest_mozwebqa.pytest_mozwebqa.TestSetup instance at 0x1034503b0>\n\n    @pytest.mark.credentials\n    def test_editing_user_profile(self, mozwebqa):\n    \n>       user = PersonaTestUser().create_user()\n\ntests/desktop/consumer_pages/test_users_account.py:48: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <persona_test_user.PersonaTestUser instance at 0x1033fe8c0>\n\n    def create_user(self):\n        url = \"http://personatestuser.org/email/\"\n>       response = urllib2.urlopen(url).read()\n\npersona_test_user.py:17: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nurl = 'http://personatestuser.org/email/', data = None\ntimeout = <object object at 0x10234d1e0>\n\n    def urlopen(url, data=None, timeout=socket._GLOBAL_DEFAULT_TIMEOUT):\n        global _opener\n        if _opener is None:\n            _opener = build_opener()\n>       return _opener.open(url, data, timeout)\n\n/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/urllib2.py:127: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <urllib2.OpenerDirector instance at 0x1033fbdd0>\nfullurl = 'http://personatestuser.org/email/', data = None\ntimeout = <object object at 0x10234d1e0>\n\n    def open(self, fullurl, data=None, timeout=socket._GLOBAL_DEFAULT_TIMEOUT):\n        # accept a URL or a Request object\n        if isinstance(fullurl, basestring):\n            req = Request(fullurl, data)\n        else:\n            req = fullurl\n            if data is not None:\n                req.add_data(data)\n    \n        req.timeout = timeout\n        protocol = req.get_type()\n    \n        # pre-process request\n        meth_name = protocol+\"_request\"\n        for processor in self.process_request.get(protocol, []):\n            meth = getattr(processor, meth_name)\n            req = meth(req)\n    \n>       response = self._open(req, data)\n\n/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/urllib2.py:404: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <urllib2.OpenerDirector instance at 0x1033fbdd0>\nreq = <urllib2.Request instance at 0x1024beef0>, data = None\n\n    def _open(self, req, data=None):\n        result = self._call_chain(self.handle_open, 'default',\n                                  'default_open', req)\n        if result:\n            return result\n    \n        protocol = req.get_type()\n        result = self._call_chain(self.handle_open, protocol, protocol +\n>                                 '_open', req)\n\n/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/urllib2.py:422: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <urllib2.OpenerDirector instance at 0x1033fbdd0>\nchain = {'file': [<urllib2.FileHandler instance at 0x1033fb128>], 'ftp': [<urllib2.FTPHandler instance at 0x1033fb560>], 'http': [<urllib2.HTTPHandler instance at 0x1033fb7e8>], 'https': [<urllib2.HTTPSHandler instance at 0x1033fb5f0>], ...}\nkind = 'http', meth_name = 'http_open'\nargs = (<urllib2.Request instance at 0x1024beef0>,)\nhandlers = [<urllib2.HTTPHandler instance at 0x1033fb7e8>]\nhandler = <urllib2.HTTPHandler instance at 0x1033fb7e8>\nfunc = <bound method HTTPHandler.http_open of <urllib2.HTTPHandler instance at 0x1033fb7e8>>\n\n    def _call_chain(self, chain, kind, meth_name, *args):\n        # Handlers raise an exception if no one else should try to handle\n        # the request, or return None if they can't but another handler\n        # could.  Otherwise, they return the response.\n        handlers = chain.get(kind, ())\n        for handler in handlers:\n            func = getattr(handler, meth_name)\n    \n>           result = func(*args)\n\n/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/urllib2.py:382: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <urllib2.HTTPHandler instance at 0x1033fb7e8>\nreq = <urllib2.Request instance at 0x1024beef0>\n\n    def http_open(self, req):\n>       return self.do_open(httplib.HTTPConnection, req)\n\n/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/urllib2.py:1214: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <urllib2.HTTPHandler instance at 0x1033fb7e8>\nhttp_class = <class httplib.HTTPConnection at 0x102dbf870>\nreq = <urllib2.Request instance at 0x1024beef0>\n\n    def do_open(self, http_class, req):\n        \"\"\"Return an addinfourl object for the request, using http_class.\n    \n            http_class must implement the HTTPConnection API from httplib.\n            The addinfourl return value is a file-like object.  It also\n            has methods and attributes including:\n                - info(): return a mimetools.Message object for the headers\n                - geturl(): return the original request URL\n                - code: HTTP status code\n            \"\"\"\n        host = req.get_host()\n        if not host:\n            raise URLError('no host given')\n    \n        h = http_class(host, timeout=req.timeout) # will parse host:port\n        h.set_debuglevel(self._debuglevel)\n    \n        headers = dict(req.unredirected_hdrs)\n        headers.update(dict((k, v) for k, v in req.headers.items()\n                            if k not in headers))\n    \n        # We want to make an HTTP/1.1 request, but the addinfourl\n        # class isn't prepared to deal with a persistent connection.\n        # It will try to read all remaining data from the socket,\n        # which will block while the server waits for the next request.\n        # So make sure the connection gets closed after the (only)\n        # request.\n        headers[\"Connection\"] = \"close\"\n        headers = dict(\n            (name.title(), val) for name, val in headers.items())\n    \n        if req._tunnel_host:\n            tunnel_headers = {}\n            proxy_auth_hdr = \"Proxy-Authorization\"\n            if proxy_auth_hdr in headers:\n                tunnel_headers[proxy_auth_hdr] = headers[proxy_auth_hdr]\n                # Proxy-Authorization should not be sent to origin\n                # server.\n                del headers[proxy_auth_hdr]\n            h.set_tunnel(req._tunnel_host, headers=tunnel_headers)\n    \n        try:\n            h.request(req.get_method(), req.get_selector(), req.data, headers)\n        except socket.error, err: # XXX what error?\n            h.close()\n>           raise URLError(err)\nE           URLError: <urlopen error [Errno 8] nodename nor servname provided, or not known>\n\n/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/urllib2.py:1184: URLError"}, {"jobs": ["marketplace.stage.saucelabs"], "result": "failure", "detail": "test failure: self = <tests.desktop.consumer_pages.test_users_account.TestAccounts instance at 0x1044a16c8>\nmozwebqa = <pytest_mozwebqa.pytest_mozwebqa.TestSetup instance at 0x1044a1680>\n\n    @pytest.mark.credentials\n    def test_editing_user_profile(self, mozwebqa):\n    \n>       user = PersonaTestUser().create_user()\n\ntests/desktop/consumer_pages/test_users_account.py:48: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <persona_test_user.PersonaTestUser instance at 0x10447bc20>\n\n    def create_user(self):\n        url = \"http://personatestuser.org/email/\"\n>       response = urllib2.urlopen(url).read()\n\npersona_test_user.py:17: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nurl = 'http://personatestuser.org/email/', data = None\ntimeout = <object object at 0x1033981e0>\n\n    def urlopen(url, data=None, timeout=socket._GLOBAL_DEFAULT_TIMEOUT):\n        global _opener\n        if _opener is None:\n            _opener = build_opener()\n>       return _opener.open(url, data, timeout)\n\n/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/urllib2.py:127: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <urllib2.OpenerDirector instance at 0x104469050>\nfullurl = 'http://personatestuser.org/email/', data = None\ntimeout = <object object at 0x1033981e0>\n\n    def open(self, fullurl, data=None, timeout=socket._GLOBAL_DEFAULT_TIMEOUT):\n        # accept a URL or a Request object\n        if isinstance(fullurl, basestring):\n            req = Request(fullurl, data)\n        else:\n            req = fullurl\n            if data is not None:\n                req.add_data(data)\n    \n        req.timeout = timeout\n        protocol = req.get_type()\n    \n        # pre-process request\n        meth_name = protocol+\"_request\"\n        for processor in self.process_request.get(protocol, []):\n            meth = getattr(processor, meth_name)\n            req = meth(req)\n    \n>       response = self._open(req, data)\n\n/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/urllib2.py:404: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <urllib2.OpenerDirector instance at 0x104469050>\nreq = <urllib2.Request instance at 0x10447b998>, data = None\n\n    def _open(self, req, data=None):\n        result = self._call_chain(self.handle_open, 'default',\n                                  'default_open', req)\n        if result:\n            return result\n    \n        protocol = req.get_type()\n        result = self._call_chain(self.handle_open, protocol, protocol +\n>                                 '_open', req)\n\n/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/urllib2.py:422: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <urllib2.OpenerDirector instance at 0x104469050>\nchain = {'file': [<urllib2.FileHandler instance at 0x104469560>], 'ftp': [<urllib2.FTPHandler instance at 0x104469518>], 'http': [<urllib2.HTTPHandler instance at 0x104469638>], 'https': [<urllib2.HTTPSHandler instance at 0x1044693f8>], ...}\nkind = 'http', meth_name = 'http_open'\nargs = (<urllib2.Request instance at 0x10447b998>,)\nhandlers = [<urllib2.HTTPHandler instance at 0x104469638>]\nhandler = <urllib2.HTTPHandler instance at 0x104469638>\nfunc = <bound method HTTPHandler.http_open of <urllib2.HTTPHandler instance at 0x104469638>>\n\n    def _call_chain(self, chain, kind, meth_name, *args):\n        # Handlers raise an exception if no one else should try to handle\n        # the request, or return None if they can't but another handler\n        # could.  Otherwise, they return the response.\n        handlers = chain.get(kind, ())\n        for handler in handlers:\n            func = getattr(handler, meth_name)\n    \n>           result = func(*args)\n\n/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/urllib2.py:382: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <urllib2.HTTPHandler instance at 0x104469638>\nreq = <urllib2.Request instance at 0x10447b998>\n\n    def http_open(self, req):\n>       return self.do_open(httplib.HTTPConnection, req)\n\n/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/urllib2.py:1214: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <urllib2.HTTPHandler instance at 0x104469638>\nhttp_class = <class httplib.HTTPConnection at 0x103e0c668>\nreq = <urllib2.Request instance at 0x10447b998>\n\n    def do_open(self, http_class, req):\n        \"\"\"Return an addinfourl object for the request, using http_class.\n    \n            http_class must implement the HTTPConnection API from httplib.\n            The addinfourl return value is a file-like object.  It also\n            has methods and attributes including:\n                - info(): return a mimetools.Message object for the headers\n                - geturl(): return the original request URL\n                - code: HTTP status code\n            \"\"\"\n        host = req.get_host()\n        if not host:\n            raise URLError('no host given')\n    \n        h = http_class(host, timeout=req.timeout) # will parse host:port\n        h.set_debuglevel(self._debuglevel)\n    \n        headers = dict(req.unredirected_hdrs)\n        headers.update(dict((k, v) for k, v in req.headers.items()\n                            if k not in headers))\n    \n        # We want to make an HTTP/1.1 request, but the addinfourl\n        # class isn't prepared to deal with a persistent connection.\n        # It will try to read all remaining data from the socket,\n        # which will block while the server waits for the next request.\n        # So make sure the connection gets closed after the (only)\n        # request.\n        headers[\"Connection\"] = \"close\"\n        headers = dict(\n            (name.title(), val) for name, val in headers.items())\n    \n        if req._tunnel_host:\n            tunnel_headers = {}\n            proxy_auth_hdr = \"Proxy-Authorization\"\n            if proxy_auth_hdr in headers:\n                tunnel_headers[proxy_auth_hdr] = headers[proxy_auth_hdr]\n                # Proxy-Authorization should not be sent to origin\n                # server.\n                del headers[proxy_auth_hdr]\n            h.set_tunnel(req._tunnel_host, headers=tunnel_headers)\n    \n        try:\n            h.request(req.get_method(), req.get_selector(), req.data, headers)\n        except socket.error, err: # XXX what error?\n            h.close()\n>           raise URLError(err)\nE           URLError: <urlopen error [Errno 8] nodename nor servname provided, or not known>\n\n/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/urllib2.py:1184: URLError"}], "passed": [], "test_name": "test_editing_user_profile"}, {"skipped": {}, "all_passed": false, "environments": ["dev", "prod", "stage"], "path_to_result": "tests.desktop.consumer_pages.test_users_account/TestAccounts/test_user_can_sign_in_and_sign_out_in_consumer_pages/", "failed": [{"jobs": ["marketplace.dev.saucelabs"], "result": "failure", "detail": "test failure: self = <tests.desktop.consumer_pages.test_users_account.TestAccounts instance at 0x10b66c290>\nmozwebqa = <pytest_mozwebqa.pytest_mozwebqa.TestSetup instance at 0x10b64eb90>\n\n    @pytest.mark.credentials\n    @pytest.mark.nondestructive\n    def test_user_can_sign_in_and_sign_out_in_consumer_pages(self, mozwebqa):\n    \n        home_page = Home(mozwebqa)\n        home_page.go_to_homepage()\n>       home_page.login(user=\"default\")\n\ntests/desktop/consumer_pages/test_users_account.py:35: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <pages.desktop.consumer_pages.home.Home object at 0x10b64f690>\nuser = 'default'\n\n    def login(self, user=None):\n>       credentials = isinstance(user, MockUser) and user or self.testsetup.credentials.get(user, PersonaTestUser().create_user())\n\npages/desktop/consumer_pages/base.py:40: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <persona_test_user.PersonaTestUser instance at 0x10b63d4d0>\n\n    def create_user(self):\n        url = \"http://personatestuser.org/email/\"\n>       response = urllib2.urlopen(url).read()\n\npersona_test_user.py:17: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nurl = 'http://personatestuser.org/email/', data = None\ntimeout = <object object at 0x1095071e0>\n\n    def urlopen(url, data=None, timeout=socket._GLOBAL_DEFAULT_TIMEOUT):\n        global _opener\n        if _opener is None:\n            _opener = build_opener()\n>       return _opener.open(url, data, timeout)\n\n/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/urllib2.py:127: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <urllib2.OpenerDirector instance at 0x10a5b8fc8>\nfullurl = 'http://personatestuser.org/email/', data = None\ntimeout = <object object at 0x1095071e0>\n\n    def open(self, fullurl, data=None, timeout=socket._GLOBAL_DEFAULT_TIMEOUT):\n        # accept a URL or a Request object\n        if isinstance(fullurl, basestring):\n            req = Request(fullurl, data)\n        else:\n            req = fullurl\n            if data is not None:\n                req.add_data(data)\n    \n        req.timeout = timeout\n        protocol = req.get_type()\n    \n        # pre-process request\n        meth_name = protocol+\"_request\"\n        for processor in self.process_request.get(protocol, []):\n            meth = getattr(processor, meth_name)\n            req = meth(req)\n    \n>       response = self._open(req, data)\n\n/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/urllib2.py:404: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <urllib2.OpenerDirector instance at 0x10a5b8fc8>\nreq = <urllib2.Request instance at 0x10b63d200>, data = None\n\n    def _open(self, req, data=None):\n        result = self._call_chain(self.handle_open, 'default',\n                                  'default_open', req)\n        if result:\n            return result\n    \n        protocol = req.get_type()\n        result = self._call_chain(self.handle_open, protocol, protocol +\n>                                 '_open', req)\n\n/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/urllib2.py:422: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <urllib2.OpenerDirector instance at 0x10a5b8fc8>\nchain = {'file': [<urllib2.FileHandler instance at 0x10a5b88c0>], 'ftp': [<urllib2.FTPHandler instance at 0x10a5b86c8>], 'http': [<urllib2.HTTPHandler instance at 0x10a5b8ef0>], 'https': [<urllib2.HTTPSHandler instance at 0x10a5b4d88>], ...}\nkind = 'http', meth_name = 'http_open'\nargs = (<urllib2.Request instance at 0x10b63d200>,)\nhandlers = [<urllib2.HTTPHandler instance at 0x10a5b8ef0>]\nhandler = <urllib2.HTTPHandler instance at 0x10a5b8ef0>\nfunc = <bound method HTTPHandler.http_open of <urllib2.HTTPHandler instance at 0x10a5b8ef0>>\n\n    def _call_chain(self, chain, kind, meth_name, *args):\n        # Handlers raise an exception if no one else should try to handle\n        # the request, or return None if they can't but another handler\n        # could.  Otherwise, they return the response.\n        handlers = chain.get(kind, ())\n        for handler in handlers:\n            func = getattr(handler, meth_name)\n    \n>           result = func(*args)\n\n/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/urllib2.py:382: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <urllib2.HTTPHandler instance at 0x10a5b8ef0>\nreq = <urllib2.Request instance at 0x10b63d200>\n\n    def http_open(self, req):\n>       return self.do_open(httplib.HTTPConnection, req)\n\n/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/urllib2.py:1214: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <urllib2.HTTPHandler instance at 0x10a5b8ef0>\nhttp_class = <class httplib.HTTPConnection at 0x109f79870>\nreq = <urllib2.Request instance at 0x10b63d200>\n\n    def do_open(self, http_class, req):\n        \"\"\"Return an addinfourl object for the request, using http_class.\n    \n            http_class must implement the HTTPConnection API from httplib.\n            The addinfourl return value is a file-like object.  It also\n            has methods and attributes including:\n                - info(): return a mimetools.Message object for the headers\n                - geturl(): return the original request URL\n                - code: HTTP status code\n            \"\"\"\n        host = req.get_host()\n        if not host:\n            raise URLError('no host given')\n    \n        h = http_class(host, timeout=req.timeout) # will parse host:port\n        h.set_debuglevel(self._debuglevel)\n    \n        headers = dict(req.unredirected_hdrs)\n        headers.update(dict((k, v) for k, v in req.headers.items()\n                            if k not in headers))\n    \n        # We want to make an HTTP/1.1 request, but the addinfourl\n        # class isn't prepared to deal with a persistent connection.\n        # It will try to read all remaining data from the socket,\n        # which will block while the server waits for the next request.\n        # So make sure the connection gets closed after the (only)\n        # request.\n        headers[\"Connection\"] = \"close\"\n        headers = dict(\n            (name.title(), val) for name, val in headers.items())\n    \n        if req._tunnel_host:\n            tunnel_headers = {}\n            proxy_auth_hdr = \"Proxy-Authorization\"\n            if proxy_auth_hdr in headers:\n                tunnel_headers[proxy_auth_hdr] = headers[proxy_auth_hdr]\n                # Proxy-Authorization should not be sent to origin\n                # server.\n                del headers[proxy_auth_hdr]\n            h.set_tunnel(req._tunnel_host, headers=tunnel_headers)\n    \n        try:\n            h.request(req.get_method(), req.get_selector(), req.data, headers)\n        except socket.error, err: # XXX what error?\n            h.close()\n>           raise URLError(err)\nE           URLError: <urlopen error [Errno 8] nodename nor servname provided, or not known>\n\n/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/urllib2.py:1184: URLError"}, {"jobs": ["marketplace.prod"], "result": "failure", "detail": "test failure: self = <tests.desktop.consumer_pages.test_users_account.TestAccounts instance at 0x1070556c8>\nmozwebqa = <pytest_mozwebqa.pytest_mozwebqa.TestSetup instance at 0x107055320>\n\n    @pytest.mark.credentials\n    @pytest.mark.nondestructive\n    def test_user_can_sign_in_and_sign_out_in_consumer_pages(self, mozwebqa):\n    \n        home_page = Home(mozwebqa)\n        home_page.go_to_homepage()\n>       home_page.login(user=\"default\")\n\ntests/desktop/consumer_pages/test_users_account.py:35: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <pages.desktop.consumer_pages.home.Home object at 0x1070b1050>\nuser = 'default'\n\n    def login(self, user=None):\n>       credentials = isinstance(user, MockUser) and user or self.testsetup.credentials.get(user, PersonaTestUser().create_user())\n\npages/desktop/consumer_pages/base.py:40: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <persona_test_user.PersonaTestUser instance at 0x10705e7e8>\n\n    def create_user(self):\n        url = \"http://personatestuser.org/email/\"\n>       response = urllib2.urlopen(url).read()\n\npersona_test_user.py:17: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nurl = 'http://personatestuser.org/email/', data = None\ntimeout = <object object at 0x105f881e0>\n\n    def urlopen(url, data=None, timeout=socket._GLOBAL_DEFAULT_TIMEOUT):\n        global _opener\n        if _opener is None:\n            _opener = build_opener()\n>       return _opener.open(url, data, timeout)\n\n/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/urllib2.py:127: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <urllib2.OpenerDirector instance at 0x10704bfc8>\nfullurl = 'http://personatestuser.org/email/', data = None\ntimeout = <object object at 0x105f881e0>\n\n    def open(self, fullurl, data=None, timeout=socket._GLOBAL_DEFAULT_TIMEOUT):\n        # accept a URL or a Request object\n        if isinstance(fullurl, basestring):\n            req = Request(fullurl, data)\n        else:\n            req = fullurl\n            if data is not None:\n                req.add_data(data)\n    \n        req.timeout = timeout\n        protocol = req.get_type()\n    \n        # pre-process request\n        meth_name = protocol+\"_request\"\n        for processor in self.process_request.get(protocol, []):\n            meth = getattr(processor, meth_name)\n            req = meth(req)\n    \n>       response = self._open(req, data)\n\n/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/urllib2.py:404: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <urllib2.OpenerDirector instance at 0x10704bfc8>\nreq = <urllib2.Request instance at 0x10704bcf8>, data = None\n\n    def _open(self, req, data=None):\n        result = self._call_chain(self.handle_open, 'default',\n                                  'default_open', req)\n        if result:\n            return result\n    \n        protocol = req.get_type()\n        result = self._call_chain(self.handle_open, protocol, protocol +\n>                                 '_open', req)\n\n/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/urllib2.py:422: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <urllib2.OpenerDirector instance at 0x10704bfc8>\nchain = {'file': [<urllib2.FileHandler instance at 0x107035998>], 'ftp': [<urllib2.FTPHandler instance at 0x107035680>], 'http': [<urllib2.HTTPHandler instance at 0x107035e18>], 'https': [<urllib2.HTTPSHandler instance at 0x107035d40>], ...}\nkind = 'http', meth_name = 'http_open'\nargs = (<urllib2.Request instance at 0x10704bcf8>,)\nhandlers = [<urllib2.HTTPHandler instance at 0x107035e18>]\nhandler = <urllib2.HTTPHandler instance at 0x107035e18>\nfunc = <bound method HTTPHandler.http_open of <urllib2.HTTPHandler instance at 0x107035e18>>\n\n    def _call_chain(self, chain, kind, meth_name, *args):\n        # Handlers raise an exception if no one else should try to handle\n        # the request, or return None if they can't but another handler\n        # could.  Otherwise, they return the response.\n        handlers = chain.get(kind, ())\n        for handler in handlers:\n            func = getattr(handler, meth_name)\n    \n>           result = func(*args)\n\n/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/urllib2.py:382: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <urllib2.HTTPHandler instance at 0x107035e18>\nreq = <urllib2.Request instance at 0x10704bcf8>\n\n    def http_open(self, req):\n>       return self.do_open(httplib.HTTPConnection, req)\n\n/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/urllib2.py:1214: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <urllib2.HTTPHandler instance at 0x107035e18>\nhttp_class = <class httplib.HTTPConnection at 0x1069fc940>\nreq = <urllib2.Request instance at 0x10704bcf8>\n\n    def do_open(self, http_class, req):\n        \"\"\"Return an addinfourl object for the request, using http_class.\n    \n            http_class must implement the HTTPConnection API from httplib.\n            The addinfourl return value is a file-like object.  It also\n            has methods and attributes including:\n                - info(): return a mimetools.Message object for the headers\n                - geturl(): return the original request URL\n                - code: HTTP status code\n            \"\"\"\n        host = req.get_host()\n        if not host:\n            raise URLError('no host given')\n    \n        h = http_class(host, timeout=req.timeout) # will parse host:port\n        h.set_debuglevel(self._debuglevel)\n    \n        headers = dict(req.unredirected_hdrs)\n        headers.update(dict((k, v) for k, v in req.headers.items()\n                            if k not in headers))\n    \n        # We want to make an HTTP/1.1 request, but the addinfourl\n        # class isn't prepared to deal with a persistent connection.\n        # It will try to read all remaining data from the socket,\n        # which will block while the server waits for the next request.\n        # So make sure the connection gets closed after the (only)\n        # request.\n        headers[\"Connection\"] = \"close\"\n        headers = dict(\n            (name.title(), val) for name, val in headers.items())\n    \n        if req._tunnel_host:\n            tunnel_headers = {}\n            proxy_auth_hdr = \"Proxy-Authorization\"\n            if proxy_auth_hdr in headers:\n                tunnel_headers[proxy_auth_hdr] = headers[proxy_auth_hdr]\n                # Proxy-Authorization should not be sent to origin\n                # server.\n                del headers[proxy_auth_hdr]\n            h.set_tunnel(req._tunnel_host, headers=tunnel_headers)\n    \n        try:\n            h.request(req.get_method(), req.get_selector(), req.data, headers)\n        except socket.error, err: # XXX what error?\n            h.close()\n>           raise URLError(err)\nE           URLError: <urlopen error [Errno 8] nodename nor servname provided, or not known>\n\n/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/urllib2.py:1184: URLError"}, {"jobs": ["marketplace.stage.saucelabs"], "result": "failure", "detail": "test failure: self = <tests.desktop.consumer_pages.test_users_account.TestAccounts instance at 0x10188bbd8>\nmozwebqa = <pytest_mozwebqa.pytest_mozwebqa.TestSetup instance at 0x1017c4c68>\n\n    @pytest.mark.credentials\n    @pytest.mark.nondestructive\n    def test_user_can_sign_in_and_sign_out_in_consumer_pages(self, mozwebqa):\n    \n        home_page = Home(mozwebqa)\n        home_page.go_to_homepage()\n>       home_page.login(user=\"default\")\n\ntests/desktop/consumer_pages/test_users_account.py:35: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <pages.desktop.consumer_pages.home.Home object at 0x101865450>\nuser = 'default'\n\n    def login(self, user=None):\n>       credentials = isinstance(user, MockUser) and user or self.testsetup.credentials.get(user, PersonaTestUser().create_user())\n\npages/desktop/consumer_pages/base.py:40: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <persona_test_user.PersonaTestUser instance at 0x10183b170>\n\n    def create_user(self):\n        url = \"http://personatestuser.org/email/\"\n>       response = urllib2.urlopen(url).read()\n\npersona_test_user.py:17: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nurl = 'http://personatestuser.org/email/', data = None\ntimeout = <object object at 0x10078a1e0>\n\n    def urlopen(url, data=None, timeout=socket._GLOBAL_DEFAULT_TIMEOUT):\n        global _opener\n        if _opener is None:\n            _opener = build_opener()\n>       return _opener.open(url, data, timeout)\n\n/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/urllib2.py:127: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <urllib2.OpenerDirector instance at 0x10180bb00>\nfullurl = 'http://personatestuser.org/email/', data = None\ntimeout = <object object at 0x10078a1e0>\n\n    def open(self, fullurl, data=None, timeout=socket._GLOBAL_DEFAULT_TIMEOUT):\n        # accept a URL or a Request object\n        if isinstance(fullurl, basestring):\n            req = Request(fullurl, data)\n        else:\n            req = fullurl\n            if data is not None:\n                req.add_data(data)\n    \n        req.timeout = timeout\n        protocol = req.get_type()\n    \n        # pre-process request\n        meth_name = protocol+\"_request\"\n        for processor in self.process_request.get(protocol, []):\n            meth = getattr(processor, meth_name)\n            req = meth(req)\n    \n>       response = self._open(req, data)\n\n/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/urllib2.py:404: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <urllib2.OpenerDirector instance at 0x10180bb00>\nreq = <urllib2.Request instance at 0x1018643b0>, data = None\n\n    def _open(self, req, data=None):\n        result = self._call_chain(self.handle_open, 'default',\n                                  'default_open', req)\n        if result:\n            return result\n    \n        protocol = req.get_type()\n        result = self._call_chain(self.handle_open, protocol, protocol +\n>                                 '_open', req)\n\n/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/urllib2.py:422: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <urllib2.OpenerDirector instance at 0x10180bb00>\nchain = {'file': [<urllib2.FileHandler instance at 0x101808ea8>], 'ftp': [<urllib2.FTPHandler instance at 0x101808950>], 'http': [<urllib2.HTTPHandler instance at 0x10180bb48>], 'https': [<urllib2.HTTPSHandler instance at 0x101808cf8>], ...}\nkind = 'http', meth_name = 'http_open'\nargs = (<urllib2.Request instance at 0x1018643b0>,)\nhandlers = [<urllib2.HTTPHandler instance at 0x10180bb48>]\nhandler = <urllib2.HTTPHandler instance at 0x10180bb48>\nfunc = <bound method HTTPHandler.http_open of <urllib2.HTTPHandler instance at 0x10180bb48>>\n\n    def _call_chain(self, chain, kind, meth_name, *args):\n        # Handlers raise an exception if no one else should try to handle\n        # the request, or return None if they can't but another handler\n        # could.  Otherwise, they return the response.\n        handlers = chain.get(kind, ())\n        for handler in handlers:\n            func = getattr(handler, meth_name)\n    \n>           result = func(*args)\n\n/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/urllib2.py:382: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <urllib2.HTTPHandler instance at 0x10180bb48>\nreq = <urllib2.Request instance at 0x1018643b0>\n\n    def http_open(self, req):\n>       return self.do_open(httplib.HTTPConnection, req)\n\n/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/urllib2.py:1214: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <urllib2.HTTPHandler instance at 0x10180bb48>\nhttp_class = <class httplib.HTTPConnection at 0x1011fe668>\nreq = <urllib2.Request instance at 0x1018643b0>\n\n    def do_open(self, http_class, req):\n        \"\"\"Return an addinfourl object for the request, using http_class.\n    \n            http_class must implement the HTTPConnection API from httplib.\n            The addinfourl return value is a file-like object.  It also\n            has methods and attributes including:\n                - info(): return a mimetools.Message object for the headers\n                - geturl(): return the original request URL\n                - code: HTTP status code\n            \"\"\"\n        host = req.get_host()\n        if not host:\n            raise URLError('no host given')\n    \n        h = http_class(host, timeout=req.timeout) # will parse host:port\n        h.set_debuglevel(self._debuglevel)\n    \n        headers = dict(req.unredirected_hdrs)\n        headers.update(dict((k, v) for k, v in req.headers.items()\n                            if k not in headers))\n    \n        # We want to make an HTTP/1.1 request, but the addinfourl\n        # class isn't prepared to deal with a persistent connection.\n        # It will try to read all remaining data from the socket,\n        # which will block while the server waits for the next request.\n        # So make sure the connection gets closed after the (only)\n        # request.\n        headers[\"Connection\"] = \"close\"\n        headers = dict(\n            (name.title(), val) for name, val in headers.items())\n    \n        if req._tunnel_host:\n            tunnel_headers = {}\n            proxy_auth_hdr = \"Proxy-Authorization\"\n            if proxy_auth_hdr in headers:\n                tunnel_headers[proxy_auth_hdr] = headers[proxy_auth_hdr]\n                # Proxy-Authorization should not be sent to origin\n                # server.\n                del headers[proxy_auth_hdr]\n            h.set_tunnel(req._tunnel_host, headers=tunnel_headers)\n    \n        try:\n            h.request(req.get_method(), req.get_selector(), req.data, headers)\n        except socket.error, err: # XXX what error?\n            h.close()\n>           raise URLError(err)\nE           URLError: <urlopen error [Errno 8] nodename nor servname provided, or not known>\n\n/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/urllib2.py:1184: URLError"}], "passed": ["marketplace.prod.saucelabs"], "test_name": "test_user_can_sign_in_and_sign_out_in_consumer_pages"}, {"skipped": {}, "all_passed": true, "environments": ["dev", "stage"], "path_to_result": "tests.desktop.consumer_pages.test_details_page/TestDetailsPage/test_that_reports_abuse_as_anonymous_user/", "failed": [], "passed": ["marketplace.dev.saucelabs", "marketplace.stage.saucelabs"], "test_name": "test_that_reports_abuse_as_anonymous_user"}, {"skipped": {}, "all_passed": true, "environments": ["stage", "dev"], "path_to_result": "tests.desktop.developer_hub.test_api_submit/TestAPI/test_assert_that_a_app_can_be_added_and_deleted_via_the_api/", "failed": [], "passed": ["marketplace.stage.developer_hub.saucelabs", "marketplace.dev.developer_hub", "marketplace.dev.developer_hub.saucelabs"], "test_name": "test_assert_that_a_app_can_be_added_and_deleted_via_the_api"}, {"skipped": {}, "all_passed": true, "environments": ["dev", "prod", "stage"], "path_to_result": "tests.desktop.consumer_pages.test_consumers_page/TestConsumerPage/test_that_header_has_expected_items/", "failed": [], "passed": ["marketplace.dev.saucelabs", "marketplace.prod", "marketplace.stage.saucelabs", "marketplace.prod.saucelabs"], "test_name": "test_that_header_has_expected_items"}, {"skipped": {}, "all_passed": true, "environments": ["stage", "dev"], "path_to_result": "tests.desktop.developer_hub.test_developer_hub/TestDeveloperHub/test_that_a_screenshot_cannot_be_added_via_an_invalid_file_format/", "failed": [], "passed": ["marketplace.stage.developer_hub.saucelabs", "marketplace.dev.developer_hub", "marketplace.dev.developer_hub.saucelabs"], "test_name": "test_that_a_screenshot_cannot_be_added_via_an_invalid_file_format"}, {"skipped": {"jobs": ["marketplace.dev.saucelabs", "marketplace.stage.saucelabs"], "result": "skipped", "detail": "Purchase app option is currently not available for desktop environment: /Users/Shared/Jenkins/Home/jobs/marketplace.dev.saucelabs/workspace/.env/lib/python2.7/site-packages/_pytest/skipping.py:120: Skipped: Purchase app option is currently not available for desktop environment"}, "all_passed": true, "environments": ["dev", "stage"], "path_to_result": "tests.desktop.consumer_pages.test_purchase_app/TestPurchaseApp/test_that_purchases_an_app_without_pre_auth_and_requests_a_refund/", "failed": [], "passed": [], "test_name": "test_that_purchases_an_app_without_pre_auth_and_requests_a_refund"}, {"skipped": {}, "all_passed": false, "environments": ["dev", "stage"], "path_to_result": "tests.desktop.consumer_pages.test_reviews/TestReviews/test_that_checks_the_deletion_of_a_review/", "failed": [{"jobs": ["marketplace.dev.saucelabs"], "result": "failure", "detail": "test failure: self = <tests.desktop.consumer_pages.test_reviews.TestReviews instance at 0x105f4fdd0>\nmozwebqa = <pytest_mozwebqa.pytest_mozwebqa.TestSetup instance at 0x105f4ff38>\n\n    @pytest.mark.credentials\n    def test_that_checks_the_deletion_of_a_review(self, mozwebqa):\n        \"\"\"\n            https://moztrap.mozilla.org/manage/case/648/\n            \"\"\"\n    \n        self._reviews_setup(mozwebqa)\n    \n        # Step 1 - Login into Marketplace\n        home_page = Home(mozwebqa)\n        home_page.go_to_homepage()\n    \n>       home_page.login(user=\"default\")\n\ntests/desktop/consumer_pages/test_reviews.py:126: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <pages.desktop.consumer_pages.home.Home object at 0x1056ae350>\nuser = 'default'\n\n    def login(self, user=None):\n>       credentials = isinstance(user, MockUser) and user or self.testsetup.credentials.get(user, PersonaTestUser().create_user())\n\npages/desktop/consumer_pages/base.py:40: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <persona_test_user.PersonaTestUser instance at 0x105fa2ea8>\n\n    def create_user(self):\n        url = \"http://personatestuser.org/email/\"\n>       response = urllib2.urlopen(url).read()\n\npersona_test_user.py:17: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nurl = 'http://personatestuser.org/email/', data = None\ntimeout = <object object at 0x104e2d1e0>\n\n    def urlopen(url, data=None, timeout=socket._GLOBAL_DEFAULT_TIMEOUT):\n        global _opener\n        if _opener is None:\n            _opener = build_opener()\n>       return _opener.open(url, data, timeout)\n\n/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/urllib2.py:127: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <urllib2.OpenerDirector instance at 0x105f09b90>\nfullurl = 'http://personatestuser.org/email/', data = None\ntimeout = <object object at 0x104e2d1e0>\n\n    def open(self, fullurl, data=None, timeout=socket._GLOBAL_DEFAULT_TIMEOUT):\n        # accept a URL or a Request object\n        if isinstance(fullurl, basestring):\n            req = Request(fullurl, data)\n        else:\n            req = fullurl\n            if data is not None:\n                req.add_data(data)\n    \n        req.timeout = timeout\n        protocol = req.get_type()\n    \n        # pre-process request\n        meth_name = protocol+\"_request\"\n        for processor in self.process_request.get(protocol, []):\n            meth = getattr(processor, meth_name)\n            req = meth(req)\n    \n>       response = self._open(req, data)\n\n/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/urllib2.py:404: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <urllib2.OpenerDirector instance at 0x105f09b90>\nreq = <urllib2.Request instance at 0x105f39830>, data = None\n\n    def _open(self, req, data=None):\n        result = self._call_chain(self.handle_open, 'default',\n                                  'default_open', req)\n        if result:\n            return result\n    \n        protocol = req.get_type()\n        result = self._call_chain(self.handle_open, protocol, protocol +\n>                                 '_open', req)\n\n/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/urllib2.py:422: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <urllib2.OpenerDirector instance at 0x105f09b90>\nchain = {'file': [<urllib2.FileHandler instance at 0x105f09f80>], 'ftp': [<urllib2.FTPHandler instance at 0x105f09ef0>], 'http': [<urllib2.HTTPHandler instance at 0x105f09c20>], 'https': [<urllib2.HTTPSHandler instance at 0x105f06128>], ...}\nkind = 'http', meth_name = 'http_open'\nargs = (<urllib2.Request instance at 0x105f39830>,)\nhandlers = [<urllib2.HTTPHandler instance at 0x105f09c20>]\nhandler = <urllib2.HTTPHandler instance at 0x105f09c20>\nfunc = <bound method HTTPHandler.http_open of <urllib2.HTTPHandler instance at 0x105f09c20>>\n\n    def _call_chain(self, chain, kind, meth_name, *args):\n        # Handlers raise an exception if no one else should try to handle\n        # the request, or return None if they can't but another handler\n        # could.  Otherwise, they return the response.\n        handlers = chain.get(kind, ())\n        for handler in handlers:\n            func = getattr(handler, meth_name)\n    \n>           result = func(*args)\n\n/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/urllib2.py:382: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <urllib2.HTTPHandler instance at 0x105f09c20>\nreq = <urllib2.Request instance at 0x105f39830>\n\n    def http_open(self, req):\n>       return self.do_open(httplib.HTTPConnection, req)\n\n/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/urllib2.py:1214: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <urllib2.HTTPHandler instance at 0x105f09c20>\nhttp_class = <class httplib.HTTPConnection at 0x10589e870>\nreq = <urllib2.Request instance at 0x105f39830>\n\n    def do_open(self, http_class, req):\n        \"\"\"Return an addinfourl object for the request, using http_class.\n    \n            http_class must implement the HTTPConnection API from httplib.\n            The addinfourl return value is a file-like object.  It also\n            has methods and attributes including:\n                - info(): return a mimetools.Message object for the headers\n                - geturl(): return the original request URL\n                - code: HTTP status code\n            \"\"\"\n        host = req.get_host()\n        if not host:\n            raise URLError('no host given')\n    \n        h = http_class(host, timeout=req.timeout) # will parse host:port\n        h.set_debuglevel(self._debuglevel)\n    \n        headers = dict(req.unredirected_hdrs)\n        headers.update(dict((k, v) for k, v in req.headers.items()\n                            if k not in headers))\n    \n        # We want to make an HTTP/1.1 request, but the addinfourl\n        # class isn't prepared to deal with a persistent connection.\n        # It will try to read all remaining data from the socket,\n        # which will block while the server waits for the next request.\n        # So make sure the connection gets closed after the (only)\n        # request.\n        headers[\"Connection\"] = \"close\"\n        headers = dict(\n            (name.title(), val) for name, val in headers.items())\n    \n        if req._tunnel_host:\n            tunnel_headers = {}\n            proxy_auth_hdr = \"Proxy-Authorization\"\n            if proxy_auth_hdr in headers:\n                tunnel_headers[proxy_auth_hdr] = headers[proxy_auth_hdr]\n                # Proxy-Authorization should not be sent to origin\n                # server.\n                del headers[proxy_auth_hdr]\n            h.set_tunnel(req._tunnel_host, headers=tunnel_headers)\n    \n        try:\n            h.request(req.get_method(), req.get_selector(), req.data, headers)\n        except socket.error, err: # XXX what error?\n            h.close()\n>           raise URLError(err)\nE           URLError: <urlopen error [Errno 8] nodename nor servname provided, or not known>\n\n/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/urllib2.py:1184: URLError"}, {"jobs": ["marketplace.stage.saucelabs"], "result": "failure", "detail": "test failure: self = <tests.desktop.consumer_pages.test_reviews.TestReviews instance at 0x10eac8e60>\nmozwebqa = <pytest_mozwebqa.pytest_mozwebqa.TestSetup instance at 0x10eac8290>\n\n    @pytest.mark.credentials\n    def test_that_checks_the_deletion_of_a_review(self, mozwebqa):\n        \"\"\"\n            https://moztrap.mozilla.org/manage/case/648/\n            \"\"\"\n    \n        self._reviews_setup(mozwebqa)\n    \n        # Step 1 - Login into Marketplace\n        home_page = Home(mozwebqa)\n        home_page.go_to_homepage()\n    \n>       home_page.login(user=\"default\")\n\ntests/desktop/consumer_pages/test_reviews.py:126: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <pages.desktop.consumer_pages.home.Home object at 0x10db55850>\nuser = 'default'\n\n    def login(self, user=None):\n>       credentials = isinstance(user, MockUser) and user or self.testsetup.credentials.get(user, PersonaTestUser().create_user())\n\npages/desktop/consumer_pages/base.py:40: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <persona_test_user.PersonaTestUser instance at 0x10eb41290>\n\n    def create_user(self):\n        url = \"http://personatestuser.org/email/\"\n>       response = urllib2.urlopen(url).read()\n\npersona_test_user.py:17: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nurl = 'http://personatestuser.org/email/', data = None\ntimeout = <object object at 0x10d9e91e0>\n\n    def urlopen(url, data=None, timeout=socket._GLOBAL_DEFAULT_TIMEOUT):\n        global _opener\n        if _opener is None:\n            _opener = build_opener()\n>       return _opener.open(url, data, timeout)\n\n/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/urllib2.py:127: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <urllib2.OpenerDirector instance at 0x10eac4518>\nfullurl = 'http://personatestuser.org/email/', data = None\ntimeout = <object object at 0x10d9e91e0>\n\n    def open(self, fullurl, data=None, timeout=socket._GLOBAL_DEFAULT_TIMEOUT):\n        # accept a URL or a Request object\n        if isinstance(fullurl, basestring):\n            req = Request(fullurl, data)\n        else:\n            req = fullurl\n            if data is not None:\n                req.add_data(data)\n    \n        req.timeout = timeout\n        protocol = req.get_type()\n    \n        # pre-process request\n        meth_name = protocol+\"_request\"\n        for processor in self.process_request.get(protocol, []):\n            meth = getattr(processor, meth_name)\n            req = meth(req)\n    \n>       response = self._open(req, data)\n\n/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/urllib2.py:404: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <urllib2.OpenerDirector instance at 0x10eac4518>\nreq = <urllib2.Request instance at 0x10fdbd320>, data = None\n\n    def _open(self, req, data=None):\n        result = self._call_chain(self.handle_open, 'default',\n                                  'default_open', req)\n        if result:\n            return result\n    \n        protocol = req.get_type()\n        result = self._call_chain(self.handle_open, protocol, protocol +\n>                                 '_open', req)\n\n/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/urllib2.py:422: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <urllib2.OpenerDirector instance at 0x10eac4518>\nchain = {'file': [<urllib2.FileHandler instance at 0x10eac4908>], 'ftp': [<urllib2.FTPHandler instance at 0x10eac4878>], 'http': [<urllib2.HTTPHandler instance at 0x10eac45a8>], 'https': [<urllib2.HTTPSHandler instance at 0x10eac4a70>], ...}\nkind = 'http', meth_name = 'http_open'\nargs = (<urllib2.Request instance at 0x10fdbd320>,)\nhandlers = [<urllib2.HTTPHandler instance at 0x10eac45a8>]\nhandler = <urllib2.HTTPHandler instance at 0x10eac45a8>\nfunc = <bound method HTTPHandler.http_open of <urllib2.HTTPHandler instance at 0x10eac45a8>>\n\n    def _call_chain(self, chain, kind, meth_name, *args):\n        # Handlers raise an exception if no one else should try to handle\n        # the request, or return None if they can't but another handler\n        # could.  Otherwise, they return the response.\n        handlers = chain.get(kind, ())\n        for handler in handlers:\n            func = getattr(handler, meth_name)\n    \n>           result = func(*args)\n\n/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/urllib2.py:382: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <urllib2.HTTPHandler instance at 0x10eac45a8>\nreq = <urllib2.Request instance at 0x10fdbd320>\n\n    def http_open(self, req):\n>       return self.do_open(httplib.HTTPConnection, req)\n\n/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/urllib2.py:1214: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <urllib2.HTTPHandler instance at 0x10eac45a8>\nhttp_class = <class httplib.HTTPConnection at 0x10e45c668>\nreq = <urllib2.Request instance at 0x10fdbd320>\n\n    def do_open(self, http_class, req):\n        \"\"\"Return an addinfourl object for the request, using http_class.\n    \n            http_class must implement the HTTPConnection API from httplib.\n            The addinfourl return value is a file-like object.  It also\n            has methods and attributes including:\n                - info(): return a mimetools.Message object for the headers\n                - geturl(): return the original request URL\n                - code: HTTP status code\n            \"\"\"\n        host = req.get_host()\n        if not host:\n            raise URLError('no host given')\n    \n        h = http_class(host, timeout=req.timeout) # will parse host:port\n        h.set_debuglevel(self._debuglevel)\n    \n        headers = dict(req.unredirected_hdrs)\n        headers.update(dict((k, v) for k, v in req.headers.items()\n                            if k not in headers))\n    \n        # We want to make an HTTP/1.1 request, but the addinfourl\n        # class isn't prepared to deal with a persistent connection.\n        # It will try to read all remaining data from the socket,\n        # which will block while the server waits for the next request.\n        # So make sure the connection gets closed after the (only)\n        # request.\n        headers[\"Connection\"] = \"close\"\n        headers = dict(\n            (name.title(), val) for name, val in headers.items())\n    \n        if req._tunnel_host:\n            tunnel_headers = {}\n            proxy_auth_hdr = \"Proxy-Authorization\"\n            if proxy_auth_hdr in headers:\n                tunnel_headers[proxy_auth_hdr] = headers[proxy_auth_hdr]\n                # Proxy-Authorization should not be sent to origin\n                # server.\n                del headers[proxy_auth_hdr]\n            h.set_tunnel(req._tunnel_host, headers=tunnel_headers)\n    \n        try:\n            h.request(req.get_method(), req.get_selector(), req.data, headers)\n        except socket.error, err: # XXX what error?\n            h.close()\n>           raise URLError(err)\nE           URLError: <urlopen error [Errno 8] nodename nor servname provided, or not known>\n\n/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/urllib2.py:1184: URLError"}], "passed": [], "test_name": "test_that_checks_the_deletion_of_a_review"}, {"skipped": {}, "all_passed": true, "environments": ["dev", "prod", "stage"], "path_to_result": "tests.desktop.consumer_pages.test_consumers_page/TestConsumerPage/test_opening_every_category_page_from_categories_section/", "failed": [], "passed": ["marketplace.dev.saucelabs", "marketplace.prod", "marketplace.stage.saucelabs", "marketplace.prod.saucelabs"], "test_name": "test_opening_every_category_page_from_categories_section"}, {"skipped": {}, "all_passed": true, "environments": ["stage", "dev"], "path_to_result": "tests.desktop.developer_hub.test_developer_hub/TestDeveloperHub/test_that_checks_editing_support_information_for_a_free_app/", "failed": [], "passed": ["marketplace.stage.developer_hub.saucelabs", "marketplace.dev.developer_hub", "marketplace.dev.developer_hub.saucelabs"], "test_name": "test_that_checks_editing_support_information_for_a_free_app"}, {"skipped": {}, "all_passed": false, "environments": ["dev", "stage"], "path_to_result": "tests.desktop.consumer_pages.test_reviews/TestReviews/test_that_checks_the_editing_of_a_review/", "failed": [{"jobs": ["marketplace.dev.saucelabs"], "result": "failure", "detail": "test failure: self = <tests.desktop.consumer_pages.test_reviews.TestReviews instance at 0x10db1c3b0>\nmozwebqa = <pytest_mozwebqa.pytest_mozwebqa.TestSetup instance at 0x10db1c638>\n\n    @pytest.mark.credentials\n    def test_that_checks_the_editing_of_a_review(self, mozwebqa):\n    \n        self._reviews_setup(mozwebqa)\n    \n        home_page = Home(mozwebqa)\n        home_page.go_to_homepage()\n    \n        # Login into Marketplace\n>       home_page.login(user=\"default\")\n\ntests/desktop/consumer_pages/test_reviews.py:85: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <pages.desktop.consumer_pages.home.Home object at 0x10da64950>\nuser = 'default'\n\n    def login(self, user=None):\n>       credentials = isinstance(user, MockUser) and user or self.testsetup.credentials.get(user, PersonaTestUser().create_user())\n\npages/desktop/consumer_pages/base.py:40: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <persona_test_user.PersonaTestUser instance at 0x10da74f80>\n\n    def create_user(self):\n        url = \"http://personatestuser.org/email/\"\n>       response = urllib2.urlopen(url).read()\n\npersona_test_user.py:17: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nurl = 'http://personatestuser.org/email/', data = None\ntimeout = <object object at 0x10c9bd1e0>\n\n    def urlopen(url, data=None, timeout=socket._GLOBAL_DEFAULT_TIMEOUT):\n        global _opener\n        if _opener is None:\n            _opener = build_opener()\n>       return _opener.open(url, data, timeout)\n\n/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/urllib2.py:127: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <urllib2.OpenerDirector instance at 0x10da98f80>\nfullurl = 'http://personatestuser.org/email/', data = None\ntimeout = <object object at 0x10c9bd1e0>\n\n    def open(self, fullurl, data=None, timeout=socket._GLOBAL_DEFAULT_TIMEOUT):\n        # accept a URL or a Request object\n        if isinstance(fullurl, basestring):\n            req = Request(fullurl, data)\n        else:\n            req = fullurl\n            if data is not None:\n                req.add_data(data)\n    \n        req.timeout = timeout\n        protocol = req.get_type()\n    \n        # pre-process request\n        meth_name = protocol+\"_request\"\n        for processor in self.process_request.get(protocol, []):\n            meth = getattr(processor, meth_name)\n            req = meth(req)\n    \n>       response = self._open(req, data)\n\n/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/urllib2.py:404: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <urllib2.OpenerDirector instance at 0x10da98f80>\nreq = <urllib2.Request instance at 0x10dae7710>, data = None\n\n    def _open(self, req, data=None):\n        result = self._call_chain(self.handle_open, 'default',\n                                  'default_open', req)\n        if result:\n            return result\n    \n        protocol = req.get_type()\n        result = self._call_chain(self.handle_open, protocol, protocol +\n>                                 '_open', req)\n\n/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/urllib2.py:422: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <urllib2.OpenerDirector instance at 0x10da98f80>\nchain = {'file': [<urllib2.FileHandler instance at 0x10da97440>], 'ftp': [<urllib2.FTPHandler instance at 0x10da973b0>], 'http': [<urllib2.HTTPHandler instance at 0x10da970e0>], 'https': [<urllib2.HTTPSHandler instance at 0x10da975a8>], ...}\nkind = 'http', meth_name = 'http_open'\nargs = (<urllib2.Request instance at 0x10dae7710>,)\nhandlers = [<urllib2.HTTPHandler instance at 0x10da970e0>]\nhandler = <urllib2.HTTPHandler instance at 0x10da970e0>\nfunc = <bound method HTTPHandler.http_open of <urllib2.HTTPHandler instance at 0x10da970e0>>\n\n    def _call_chain(self, chain, kind, meth_name, *args):\n        # Handlers raise an exception if no one else should try to handle\n        # the request, or return None if they can't but another handler\n        # could.  Otherwise, they return the response.\n        handlers = chain.get(kind, ())\n        for handler in handlers:\n            func = getattr(handler, meth_name)\n    \n>           result = func(*args)\n\n/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/urllib2.py:382: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <urllib2.HTTPHandler instance at 0x10da970e0>\nreq = <urllib2.Request instance at 0x10dae7710>\n\n    def http_open(self, req):\n>       return self.do_open(httplib.HTTPConnection, req)\n\n/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/urllib2.py:1214: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <urllib2.HTTPHandler instance at 0x10da970e0>\nhttp_class = <class httplib.HTTPConnection at 0x10d42e870>\nreq = <urllib2.Request instance at 0x10dae7710>\n\n    def do_open(self, http_class, req):\n        \"\"\"Return an addinfourl object for the request, using http_class.\n    \n            http_class must implement the HTTPConnection API from httplib.\n            The addinfourl return value is a file-like object.  It also\n            has methods and attributes including:\n                - info(): return a mimetools.Message object for the headers\n                - geturl(): return the original request URL\n                - code: HTTP status code\n            \"\"\"\n        host = req.get_host()\n        if not host:\n            raise URLError('no host given')\n    \n        h = http_class(host, timeout=req.timeout) # will parse host:port\n        h.set_debuglevel(self._debuglevel)\n    \n        headers = dict(req.unredirected_hdrs)\n        headers.update(dict((k, v) for k, v in req.headers.items()\n                            if k not in headers))\n    \n        # We want to make an HTTP/1.1 request, but the addinfourl\n        # class isn't prepared to deal with a persistent connection.\n        # It will try to read all remaining data from the socket,\n        # which will block while the server waits for the next request.\n        # So make sure the connection gets closed after the (only)\n        # request.\n        headers[\"Connection\"] = \"close\"\n        headers = dict(\n            (name.title(), val) for name, val in headers.items())\n    \n        if req._tunnel_host:\n            tunnel_headers = {}\n            proxy_auth_hdr = \"Proxy-Authorization\"\n            if proxy_auth_hdr in headers:\n                tunnel_headers[proxy_auth_hdr] = headers[proxy_auth_hdr]\n                # Proxy-Authorization should not be sent to origin\n                # server.\n                del headers[proxy_auth_hdr]\n            h.set_tunnel(req._tunnel_host, headers=tunnel_headers)\n    \n        try:\n            h.request(req.get_method(), req.get_selector(), req.data, headers)\n        except socket.error, err: # XXX what error?\n            h.close()\n>           raise URLError(err)\nE           URLError: <urlopen error [Errno 8] nodename nor servname provided, or not known>\n\n/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/urllib2.py:1184: URLError"}, {"jobs": ["marketplace.stage.saucelabs"], "result": "failure", "detail": "test failure: self = <tests.desktop.consumer_pages.test_reviews.TestReviews instance at 0x102576ef0>\nmozwebqa = <pytest_mozwebqa.pytest_mozwebqa.TestSetup instance at 0x1034ff368>\n\n    @pytest.mark.credentials\n    def test_that_checks_the_editing_of_a_review(self, mozwebqa):\n    \n        self._reviews_setup(mozwebqa)\n    \n        home_page = Home(mozwebqa)\n        home_page.go_to_homepage()\n    \n        # Login into Marketplace\n>       home_page.login(user=\"default\")\n\ntests/desktop/consumer_pages/test_reviews.py:85: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <pages.desktop.consumer_pages.home.Home object at 0x103439e90>\nuser = 'default'\n\n    def login(self, user=None):\n>       credentials = isinstance(user, MockUser) and user or self.testsetup.credentials.get(user, PersonaTestUser().create_user())\n\npages/desktop/consumer_pages/base.py:40: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <persona_test_user.PersonaTestUser instance at 0x1034f3b48>\n\n    def create_user(self):\n        url = \"http://personatestuser.org/email/\"\n>       response = urllib2.urlopen(url).read()\n\npersona_test_user.py:17: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nurl = 'http://personatestuser.org/email/', data = None\ntimeout = <object object at 0x1024051e0>\n\n    def urlopen(url, data=None, timeout=socket._GLOBAL_DEFAULT_TIMEOUT):\n        global _opener\n        if _opener is None:\n            _opener = build_opener()\n>       return _opener.open(url, data, timeout)\n\n/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/urllib2.py:127: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <urllib2.OpenerDirector instance at 0x1034e3ef0>\nfullurl = 'http://personatestuser.org/email/', data = None\ntimeout = <object object at 0x1024051e0>\n\n    def open(self, fullurl, data=None, timeout=socket._GLOBAL_DEFAULT_TIMEOUT):\n        # accept a URL or a Request object\n        if isinstance(fullurl, basestring):\n            req = Request(fullurl, data)\n        else:\n            req = fullurl\n            if data is not None:\n                req.add_data(data)\n    \n        req.timeout = timeout\n        protocol = req.get_type()\n    \n        # pre-process request\n        meth_name = protocol+\"_request\"\n        for processor in self.process_request.get(protocol, []):\n            meth = getattr(processor, meth_name)\n            req = meth(req)\n    \n>       response = self._open(req, data)\n\n/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/urllib2.py:404: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <urllib2.OpenerDirector instance at 0x1034e3ef0>\nreq = <urllib2.Request instance at 0x1034e3b00>, data = None\n\n    def _open(self, req, data=None):\n        result = self._call_chain(self.handle_open, 'default',\n                                  'default_open', req)\n        if result:\n            return result\n    \n        protocol = req.get_type()\n        result = self._call_chain(self.handle_open, protocol, protocol +\n>                                 '_open', req)\n\n/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/urllib2.py:422: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <urllib2.OpenerDirector instance at 0x1034e3ef0>\nchain = {'file': [<urllib2.FileHandler instance at 0x1034e2320>], 'ftp': [<urllib2.FTPHandler instance at 0x1034e2290>], 'http': [<urllib2.HTTPHandler instance at 0x1034e3f80>], 'https': [<urllib2.HTTPSHandler instance at 0x1034e2488>], ...}\nkind = 'http', meth_name = 'http_open'\nargs = (<urllib2.Request instance at 0x1034e3b00>,)\nhandlers = [<urllib2.HTTPHandler instance at 0x1034e3f80>]\nhandler = <urllib2.HTTPHandler instance at 0x1034e3f80>\nfunc = <bound method HTTPHandler.http_open of <urllib2.HTTPHandler instance at 0x1034e3f80>>\n\n    def _call_chain(self, chain, kind, meth_name, *args):\n        # Handlers raise an exception if no one else should try to handle\n        # the request, or return None if they can't but another handler\n        # could.  Otherwise, they return the response.\n        handlers = chain.get(kind, ())\n        for handler in handlers:\n            func = getattr(handler, meth_name)\n    \n>           result = func(*args)\n\n/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/urllib2.py:382: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <urllib2.HTTPHandler instance at 0x1034e3f80>\nreq = <urllib2.Request instance at 0x1034e3b00>\n\n    def http_open(self, req):\n>       return self.do_open(httplib.HTTPConnection, req)\n\n/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/urllib2.py:1214: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <urllib2.HTTPHandler instance at 0x1034e3f80>\nhttp_class = <class httplib.HTTPConnection at 0x102e79668>\nreq = <urllib2.Request instance at 0x1034e3b00>\n\n    def do_open(self, http_class, req):\n        \"\"\"Return an addinfourl object for the request, using http_class.\n    \n            http_class must implement the HTTPConnection API from httplib.\n            The addinfourl return value is a file-like object.  It also\n            has methods and attributes including:\n                - info(): return a mimetools.Message object for the headers\n                - geturl(): return the original request URL\n                - code: HTTP status code\n            \"\"\"\n        host = req.get_host()\n        if not host:\n            raise URLError('no host given')\n    \n        h = http_class(host, timeout=req.timeout) # will parse host:port\n        h.set_debuglevel(self._debuglevel)\n    \n        headers = dict(req.unredirected_hdrs)\n        headers.update(dict((k, v) for k, v in req.headers.items()\n                            if k not in headers))\n    \n        # We want to make an HTTP/1.1 request, but the addinfourl\n        # class isn't prepared to deal with a persistent connection.\n        # It will try to read all remaining data from the socket,\n        # which will block while the server waits for the next request.\n        # So make sure the connection gets closed after the (only)\n        # request.\n        headers[\"Connection\"] = \"close\"\n        headers = dict(\n            (name.title(), val) for name, val in headers.items())\n    \n        if req._tunnel_host:\n            tunnel_headers = {}\n            proxy_auth_hdr = \"Proxy-Authorization\"\n            if proxy_auth_hdr in headers:\n                tunnel_headers[proxy_auth_hdr] = headers[proxy_auth_hdr]\n                # Proxy-Authorization should not be sent to origin\n                # server.\n                del headers[proxy_auth_hdr]\n            h.set_tunnel(req._tunnel_host, headers=tunnel_headers)\n    \n        try:\n            h.request(req.get_method(), req.get_selector(), req.data, headers)\n        except socket.error, err: # XXX what error?\n            h.close()\n>           raise URLError(err)\nE           URLError: <urlopen error [Errno 8] nodename nor servname provided, or not known>\n\n/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/urllib2.py:1184: URLError"}], "passed": [], "test_name": "test_that_checks_the_editing_of_a_review"}, {"skipped": {}, "all_passed": true, "environments": ["stage", "dev"], "path_to_result": "tests.desktop.developer_hub.test_developer_hub/TestDeveloperHub/test_that_deletes_app/", "failed": [], "passed": ["marketplace.stage.developer_hub.saucelabs", "marketplace.dev.developer_hub", "marketplace.dev.developer_hub.saucelabs"], "test_name": "test_that_deletes_app"}, {"skipped": {}, "all_passed": true, "environments": ["dev", "prod", "stage"], "path_to_result": "tests.desktop.consumer_pages.test_consumers_page/TestConsumerPage/test_open_view_all_link_while_new_tab_selected/", "failed": [], "passed": ["marketplace.dev.saucelabs", "marketplace.prod", "marketplace.stage.saucelabs", "marketplace.prod.saucelabs"], "test_name": "test_open_view_all_link_while_new_tab_selected"}, {"skipped": {}, "all_passed": true, "environments": ["stage", "dev"], "path_to_result": "tests.desktop.developer_hub.test_developer_hub/TestDeveloperHub/test_that_checks_required_field_validations_on_basic_info_for_a_free_app/", "failed": [], "passed": ["marketplace.stage.developer_hub.saucelabs", "marketplace.dev.developer_hub", "marketplace.dev.developer_hub.saucelabs"], "test_name": "test_that_checks_required_field_validations_on_basic_info_for_a_free_app"}, {"skipped": {"jobs": ["marketplace.stage.developer_hub.saucelabs", "marketplace.dev.developer_hub", "marketplace.dev.developer_hub.saucelabs"], "result": "skipped", "detail": "xfail-marked test passes unexpectedly: None"}, "all_passed": true, "environments": ["stage", "dev"], "path_to_result": "tests.desktop.developer_hub.test_developer_hub/TestDeveloperHub/test_that_a_screenshot_can_be_added/", "failed": [], "passed": [], "test_name": "test_that_a_screenshot_can_be_added"}, {"skipped": {}, "all_passed": true, "environments": ["dev", "prod", "stage"], "path_to_result": "tests.desktop.consumer_pages.test_search/TestSearching/test_that_checks_search_with_foreign_characters/", "failed": [], "passed": ["marketplace.dev.saucelabs", "marketplace.prod", "marketplace.stage.saucelabs", "marketplace.prod.saucelabs"], "test_name": "test_that_checks_search_with_foreign_characters"}, {"skipped": {}, "all_passed": false, "environments": ["dev", "stage"], "path_to_result": "tests.desktop.consumer_pages.test_users_account/TestAccounts/test_create_new_user/", "failed": [{"jobs": ["marketplace.dev.saucelabs"], "result": "failure", "detail": "test failure: self = <tests.desktop.consumer_pages.test_users_account.TestAccounts instance at 0x1106c5f80>\nmozwebqa = <pytest_mozwebqa.pytest_mozwebqa.TestSetup instance at 0x1106c56c8>\n\n    @pytest.mark.credentials\n    def test_create_new_user(self, mozwebqa):\n        home_page = Home(mozwebqa)\n        home_page.go_to_homepage()\n    \n>       home_page.login()\n\ntests/desktop/consumer_pages/test_users_account.py:22: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <pages.desktop.consumer_pages.home.Home object at 0x1106c8290>\nuser = None\n\n    def login(self, user=None):\n>       credentials = isinstance(user, MockUser) and user or self.testsetup.credentials.get(user, PersonaTestUser().create_user())\n\npages/desktop/consumer_pages/base.py:40: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <persona_test_user.PersonaTestUser instance at 0x110680830>\n\n    def create_user(self):\n        url = \"http://personatestuser.org/email/\"\n>       response = urllib2.urlopen(url).read()\n\npersona_test_user.py:17: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nurl = 'http://personatestuser.org/email/', data = None\ntimeout = <object object at 0x10f5b01e0>\n\n    def urlopen(url, data=None, timeout=socket._GLOBAL_DEFAULT_TIMEOUT):\n        global _opener\n        if _opener is None:\n            _opener = build_opener()\n>       return _opener.open(url, data, timeout)\n\n/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/urllib2.py:127: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <urllib2.OpenerDirector instance at 0x110661fc8>\nfullurl = 'http://personatestuser.org/email/', data = None\ntimeout = <object object at 0x10f5b01e0>\n\n    def open(self, fullurl, data=None, timeout=socket._GLOBAL_DEFAULT_TIMEOUT):\n        # accept a URL or a Request object\n        if isinstance(fullurl, basestring):\n            req = Request(fullurl, data)\n        else:\n            req = fullurl\n            if data is not None:\n                req.add_data(data)\n    \n        req.timeout = timeout\n        protocol = req.get_type()\n    \n        # pre-process request\n        meth_name = protocol+\"_request\"\n        for processor in self.process_request.get(protocol, []):\n            meth = getattr(processor, meth_name)\n            req = meth(req)\n    \n>       response = self._open(req, data)\n\n/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/urllib2.py:404: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <urllib2.OpenerDirector instance at 0x110661fc8>\nreq = <urllib2.Request instance at 0x11068d3f8>, data = None\n\n    def _open(self, req, data=None):\n        result = self._call_chain(self.handle_open, 'default',\n                                  'default_open', req)\n        if result:\n            return result\n    \n        protocol = req.get_type()\n        result = self._call_chain(self.handle_open, protocol, protocol +\n>                                 '_open', req)\n\n/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/urllib2.py:422: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <urllib2.OpenerDirector instance at 0x110661fc8>\nchain = {'file': [<urllib2.FileHandler instance at 0x110661758>], 'ftp': [<urllib2.FTPHandler instance at 0x1106617e8>], 'http': [<urllib2.HTTPHandler instance at 0x110661f80>], 'https': [<urllib2.HTTPSHandler instance at 0x110638518>], ...}\nkind = 'http', meth_name = 'http_open'\nargs = (<urllib2.Request instance at 0x11068d3f8>,)\nhandlers = [<urllib2.HTTPHandler instance at 0x110661f80>]\nhandler = <urllib2.HTTPHandler instance at 0x110661f80>\nfunc = <bound method HTTPHandler.http_open of <urllib2.HTTPHandler instance at 0x110661f80>>\n\n    def _call_chain(self, chain, kind, meth_name, *args):\n        # Handlers raise an exception if no one else should try to handle\n        # the request, or return None if they can't but another handler\n        # could.  Otherwise, they return the response.\n        handlers = chain.get(kind, ())\n        for handler in handlers:\n            func = getattr(handler, meth_name)\n    \n>           result = func(*args)\n\n/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/urllib2.py:382: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <urllib2.HTTPHandler instance at 0x110661f80>\nreq = <urllib2.Request instance at 0x11068d3f8>\n\n    def http_open(self, req):\n>       return self.do_open(httplib.HTTPConnection, req)\n\n/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/urllib2.py:1214: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <urllib2.HTTPHandler instance at 0x110661f80>\nhttp_class = <class httplib.HTTPConnection at 0x110022870>\nreq = <urllib2.Request instance at 0x11068d3f8>\n\n    def do_open(self, http_class, req):\n        \"\"\"Return an addinfourl object for the request, using http_class.\n    \n            http_class must implement the HTTPConnection API from httplib.\n            The addinfourl return value is a file-like object.  It also\n            has methods and attributes including:\n                - info(): return a mimetools.Message object for the headers\n                - geturl(): return the original request URL\n                - code: HTTP status code\n            \"\"\"\n        host = req.get_host()\n        if not host:\n            raise URLError('no host given')\n    \n        h = http_class(host, timeout=req.timeout) # will parse host:port\n        h.set_debuglevel(self._debuglevel)\n    \n        headers = dict(req.unredirected_hdrs)\n        headers.update(dict((k, v) for k, v in req.headers.items()\n                            if k not in headers))\n    \n        # We want to make an HTTP/1.1 request, but the addinfourl\n        # class isn't prepared to deal with a persistent connection.\n        # It will try to read all remaining data from the socket,\n        # which will block while the server waits for the next request.\n        # So make sure the connection gets closed after the (only)\n        # request.\n        headers[\"Connection\"] = \"close\"\n        headers = dict(\n            (name.title(), val) for name, val in headers.items())\n    \n        if req._tunnel_host:\n            tunnel_headers = {}\n            proxy_auth_hdr = \"Proxy-Authorization\"\n            if proxy_auth_hdr in headers:\n                tunnel_headers[proxy_auth_hdr] = headers[proxy_auth_hdr]\n                # Proxy-Authorization should not be sent to origin\n                # server.\n                del headers[proxy_auth_hdr]\n            h.set_tunnel(req._tunnel_host, headers=tunnel_headers)\n    \n        try:\n            h.request(req.get_method(), req.get_selector(), req.data, headers)\n        except socket.error, err: # XXX what error?\n            h.close()\n>           raise URLError(err)\nE           URLError: <urlopen error [Errno 8] nodename nor servname provided, or not known>\n\n/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/urllib2.py:1184: URLError"}, {"jobs": ["marketplace.stage.saucelabs"], "result": "failure", "detail": "test failure: self = <tests.desktop.consumer_pages.test_users_account.TestAccounts instance at 0x10e2a06c8>\nmozwebqa = <pytest_mozwebqa.pytest_mozwebqa.TestSetup instance at 0x10e2a0518>\n\n    @pytest.mark.credentials\n    def test_create_new_user(self, mozwebqa):\n        home_page = Home(mozwebqa)\n        home_page.go_to_homepage()\n    \n>       home_page.login()\n\ntests/desktop/consumer_pages/test_users_account.py:22: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <pages.desktop.consumer_pages.home.Home object at 0x10e268110>\nuser = None\n\n    def login(self, user=None):\n>       credentials = isinstance(user, MockUser) and user or self.testsetup.credentials.get(user, PersonaTestUser().create_user())\n\npages/desktop/consumer_pages/base.py:40: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <persona_test_user.PersonaTestUser instance at 0x10e2af098>\n\n    def create_user(self):\n        url = \"http://personatestuser.org/email/\"\n>       response = urllib2.urlopen(url).read()\n\npersona_test_user.py:17: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nurl = 'http://personatestuser.org/email/', data = None\ntimeout = <object object at 0x10d18f1e0>\n\n    def urlopen(url, data=None, timeout=socket._GLOBAL_DEFAULT_TIMEOUT):\n        global _opener\n        if _opener is None:\n            _opener = build_opener()\n>       return _opener.open(url, data, timeout)\n\n/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/urllib2.py:127: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <urllib2.OpenerDirector instance at 0x10e24d638>\nfullurl = 'http://personatestuser.org/email/', data = None\ntimeout = <object object at 0x10d18f1e0>\n\n    def open(self, fullurl, data=None, timeout=socket._GLOBAL_DEFAULT_TIMEOUT):\n        # accept a URL or a Request object\n        if isinstance(fullurl, basestring):\n            req = Request(fullurl, data)\n        else:\n            req = fullurl\n            if data is not None:\n                req.add_data(data)\n    \n        req.timeout = timeout\n        protocol = req.get_type()\n    \n        # pre-process request\n        meth_name = protocol+\"_request\"\n        for processor in self.process_request.get(protocol, []):\n            meth = getattr(processor, meth_name)\n            req = meth(req)\n    \n>       response = self._open(req, data)\n\n/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/urllib2.py:404: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <urllib2.OpenerDirector instance at 0x10e24d638>\nreq = <urllib2.Request instance at 0x10e269ef0>, data = None\n\n    def _open(self, req, data=None):\n        result = self._call_chain(self.handle_open, 'default',\n                                  'default_open', req)\n        if result:\n            return result\n    \n        protocol = req.get_type()\n        result = self._call_chain(self.handle_open, protocol, protocol +\n>                                 '_open', req)\n\n/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/urllib2.py:422: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <urllib2.OpenerDirector instance at 0x10e24d638>\nchain = {'file': [<urllib2.FileHandler instance at 0x10e24dbd8>], 'ftp': [<urllib2.FTPHandler instance at 0x10e24db48>], 'http': [<urllib2.HTTPHandler instance at 0x10e24d7a0>], 'https': [<urllib2.HTTPSHandler instance at 0x10e24df38>], ...}\nkind = 'http', meth_name = 'http_open'\nargs = (<urllib2.Request instance at 0x10e269ef0>,)\nhandlers = [<urllib2.HTTPHandler instance at 0x10e24d7a0>]\nhandler = <urllib2.HTTPHandler instance at 0x10e24d7a0>\nfunc = <bound method HTTPHandler.http_open of <urllib2.HTTPHandler instance at 0x10e24d7a0>>\n\n    def _call_chain(self, chain, kind, meth_name, *args):\n        # Handlers raise an exception if no one else should try to handle\n        # the request, or return None if they can't but another handler\n        # could.  Otherwise, they return the response.\n        handlers = chain.get(kind, ())\n        for handler in handlers:\n            func = getattr(handler, meth_name)\n    \n>           result = func(*args)\n\n/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/urllib2.py:382: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <urllib2.HTTPHandler instance at 0x10e24d7a0>\nreq = <urllib2.Request instance at 0x10e269ef0>\n\n    def http_open(self, req):\n>       return self.do_open(httplib.HTTPConnection, req)\n\n/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/urllib2.py:1214: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <urllib2.HTTPHandler instance at 0x10e24d7a0>\nhttp_class = <class httplib.HTTPConnection at 0x10dc03668>\nreq = <urllib2.Request instance at 0x10e269ef0>\n\n    def do_open(self, http_class, req):\n        \"\"\"Return an addinfourl object for the request, using http_class.\n    \n            http_class must implement the HTTPConnection API from httplib.\n            The addinfourl return value is a file-like object.  It also\n            has methods and attributes including:\n                - info(): return a mimetools.Message object for the headers\n                - geturl(): return the original request URL\n                - code: HTTP status code\n            \"\"\"\n        host = req.get_host()\n        if not host:\n            raise URLError('no host given')\n    \n        h = http_class(host, timeout=req.timeout) # will parse host:port\n        h.set_debuglevel(self._debuglevel)\n    \n        headers = dict(req.unredirected_hdrs)\n        headers.update(dict((k, v) for k, v in req.headers.items()\n                            if k not in headers))\n    \n        # We want to make an HTTP/1.1 request, but the addinfourl\n        # class isn't prepared to deal with a persistent connection.\n        # It will try to read all remaining data from the socket,\n        # which will block while the server waits for the next request.\n        # So make sure the connection gets closed after the (only)\n        # request.\n        headers[\"Connection\"] = \"close\"\n        headers = dict(\n            (name.title(), val) for name, val in headers.items())\n    \n        if req._tunnel_host:\n            tunnel_headers = {}\n            proxy_auth_hdr = \"Proxy-Authorization\"\n            if proxy_auth_hdr in headers:\n                tunnel_headers[proxy_auth_hdr] = headers[proxy_auth_hdr]\n                # Proxy-Authorization should not be sent to origin\n                # server.\n                del headers[proxy_auth_hdr]\n            h.set_tunnel(req._tunnel_host, headers=tunnel_headers)\n    \n        try:\n            h.request(req.get_method(), req.get_selector(), req.data, headers)\n        except socket.error, err: # XXX what error?\n            h.close()\n>           raise URLError(err)\nE           URLError: <urlopen error [Errno 8] nodename nor servname provided, or not known>\n\n/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/urllib2.py:1184: URLError"}], "passed": [], "test_name": "test_create_new_user"}, {"skipped": {}, "all_passed": true, "environments": ["stage", "dev"], "path_to_result": "tests.desktop.developer_hub.test_developer_hub/TestDeveloperHub/test_that_checks_required_field_validations_on_device_types_for_hosted_apps/", "failed": [], "passed": ["marketplace.stage.developer_hub.saucelabs", "marketplace.dev.developer_hub", "marketplace.dev.developer_hub.saucelabs"], "test_name": "test_that_checks_required_field_validations_on_device_types_for_hosted_apps"}, {"skipped": {}, "all_passed": true, "environments": ["dev", "prod", "stage"], "path_to_result": "tests.desktop.consumer_pages.test_search/TestSearching/test_that_searching_with_empty_field_using_submit_returns_results/", "failed": [], "passed": ["marketplace.dev.saucelabs", "marketplace.prod", "marketplace.stage.saucelabs", "marketplace.prod.saucelabs"], "test_name": "test_that_searching_with_empty_field_using_submit_returns_results"}, {"skipped": {}, "all_passed": true, "environments": ["dev", "prod", "stage"], "path_to_result": "tests.desktop.consumer_pages.test_consumers_page/TestConsumerPage/test_that_verifies_categories_section/", "failed": [], "passed": ["marketplace.dev.saucelabs", "marketplace.prod", "marketplace.stage.saucelabs", "marketplace.prod.saucelabs"], "test_name": "test_that_verifies_categories_section"}, {"skipped": {"jobs": ["marketplace.dev.saucelabs", "marketplace.prod", "marketplace.stage.saucelabs", "marketplace.prod.saucelabs"], "result": "skipped", "detail": "Sort not available yet.: /Users/Shared/Jenkins/Home/jobs/marketplace.dev.saucelabs/workspace/.env/lib/python2.7/site-packages/_pytest/skipping.py:120: Skipped: Sort not available yet."}, "all_passed": true, "environments": ["dev", "prod", "stage"], "path_to_result": "tests.desktop.consumer_pages.test_search/TestSearching/test_that_verifies_the_sort_region_from_search_results[Rating]/", "failed": [], "passed": [], "test_name": "test_that_verifies_the_sort_region_from_search_results[Rating]"}, {"skipped": {}, "all_passed": false, "environments": ["dev", "stage"], "path_to_result": "tests.desktop.consumer_pages.test_details_page/TestDetailsPage/test_that_reports_abuse_as_signed_in_user/", "failed": [{"jobs": ["marketplace.dev.saucelabs"], "result": "failure", "detail": "test failure: self = <tests.desktop.consumer_pages.test_details_page.TestDetailsPage instance at 0x10428d950>\nmozwebqa = <pytest_mozwebqa.pytest_mozwebqa.TestSetup instance at 0x10428def0>\n\n    @pytest.mark.credentials\n    def test_that_reports_abuse_as_signed_in_user(self, mozwebqa):\n    \n        home_page = Home(mozwebqa)\n        home_page.go_to_homepage()\n    \n        Assert.true(home_page.is_the_current_page)\n>       home_page.login(user=\"default\")\n\ntests/desktop/consumer_pages/test_details_page.py:96: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <pages.desktop.consumer_pages.home.Home object at 0x104299e10>\nuser = 'default'\n\n    def login(self, user=None):\n>       credentials = isinstance(user, MockUser) and user or self.testsetup.credentials.get(user, PersonaTestUser().create_user())\n\npages/desktop/consumer_pages/base.py:40: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <persona_test_user.PersonaTestUser instance at 0x10430ce60>\n\n    def create_user(self):\n        url = \"http://personatestuser.org/email/\"\n>       response = urllib2.urlopen(url).read()\n\npersona_test_user.py:17: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nurl = 'http://personatestuser.org/email/', data = None\ntimeout = <object object at 0x1031de1e0>\n\n    def urlopen(url, data=None, timeout=socket._GLOBAL_DEFAULT_TIMEOUT):\n        global _opener\n        if _opener is None:\n            _opener = build_opener()\n>       return _opener.open(url, data, timeout)\n\n/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/urllib2.py:127: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <urllib2.OpenerDirector instance at 0x104295320>\nfullurl = 'http://personatestuser.org/email/', data = None\ntimeout = <object object at 0x1031de1e0>\n\n    def open(self, fullurl, data=None, timeout=socket._GLOBAL_DEFAULT_TIMEOUT):\n        # accept a URL or a Request object\n        if isinstance(fullurl, basestring):\n            req = Request(fullurl, data)\n        else:\n            req = fullurl\n            if data is not None:\n                req.add_data(data)\n    \n        req.timeout = timeout\n        protocol = req.get_type()\n    \n        # pre-process request\n        meth_name = protocol+\"_request\"\n        for processor in self.process_request.get(protocol, []):\n            meth = getattr(processor, meth_name)\n            req = meth(req)\n    \n>       response = self._open(req, data)\n\n/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/urllib2.py:404: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <urllib2.OpenerDirector instance at 0x104295320>\nreq = <urllib2.Request instance at 0x1042148c0>, data = None\n\n    def _open(self, req, data=None):\n        result = self._call_chain(self.handle_open, 'default',\n                                  'default_open', req)\n        if result:\n            return result\n    \n        protocol = req.get_type()\n        result = self._call_chain(self.handle_open, protocol, protocol +\n>                                 '_open', req)\n\n/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/urllib2.py:422: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <urllib2.OpenerDirector instance at 0x104295320>\nchain = {'file': [<urllib2.FileHandler instance at 0x104295758>], 'ftp': [<urllib2.FTPHandler instance at 0x1042956c8>], 'http': [<urllib2.HTTPHandler instance at 0x1042953f8>], 'https': [<urllib2.HTTPSHandler instance at 0x1042958c0>], ...}\nkind = 'http', meth_name = 'http_open'\nargs = (<urllib2.Request instance at 0x1042148c0>,)\nhandlers = [<urllib2.HTTPHandler instance at 0x1042953f8>]\nhandler = <urllib2.HTTPHandler instance at 0x1042953f8>\nfunc = <bound method HTTPHandler.http_open of <urllib2.HTTPHandler instance at 0x1042953f8>>\n\n    def _call_chain(self, chain, kind, meth_name, *args):\n        # Handlers raise an exception if no one else should try to handle\n        # the request, or return None if they can't but another handler\n        # could.  Otherwise, they return the response.\n        handlers = chain.get(kind, ())\n        for handler in handlers:\n            func = getattr(handler, meth_name)\n    \n>           result = func(*args)\n\n/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/urllib2.py:382: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <urllib2.HTTPHandler instance at 0x1042953f8>\nreq = <urllib2.Request instance at 0x1042148c0>\n\n    def http_open(self, req):\n>       return self.do_open(httplib.HTTPConnection, req)\n\n/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/urllib2.py:1214: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <urllib2.HTTPHandler instance at 0x1042953f8>\nhttp_class = <class httplib.HTTPConnection at 0x103c4f870>\nreq = <urllib2.Request instance at 0x1042148c0>\n\n    def do_open(self, http_class, req):\n        \"\"\"Return an addinfourl object for the request, using http_class.\n    \n            http_class must implement the HTTPConnection API from httplib.\n            The addinfourl return value is a file-like object.  It also\n            has methods and attributes including:\n                - info(): return a mimetools.Message object for the headers\n                - geturl(): return the original request URL\n                - code: HTTP status code\n            \"\"\"\n        host = req.get_host()\n        if not host:\n            raise URLError('no host given')\n    \n        h = http_class(host, timeout=req.timeout) # will parse host:port\n        h.set_debuglevel(self._debuglevel)\n    \n        headers = dict(req.unredirected_hdrs)\n        headers.update(dict((k, v) for k, v in req.headers.items()\n                            if k not in headers))\n    \n        # We want to make an HTTP/1.1 request, but the addinfourl\n        # class isn't prepared to deal with a persistent connection.\n        # It will try to read all remaining data from the socket,\n        # which will block while the server waits for the next request.\n        # So make sure the connection gets closed after the (only)\n        # request.\n        headers[\"Connection\"] = \"close\"\n        headers = dict(\n            (name.title(), val) for name, val in headers.items())\n    \n        if req._tunnel_host:\n            tunnel_headers = {}\n            proxy_auth_hdr = \"Proxy-Authorization\"\n            if proxy_auth_hdr in headers:\n                tunnel_headers[proxy_auth_hdr] = headers[proxy_auth_hdr]\n                # Proxy-Authorization should not be sent to origin\n                # server.\n                del headers[proxy_auth_hdr]\n            h.set_tunnel(req._tunnel_host, headers=tunnel_headers)\n    \n        try:\n            h.request(req.get_method(), req.get_selector(), req.data, headers)\n        except socket.error, err: # XXX what error?\n            h.close()\n>           raise URLError(err)\nE           URLError: <urlopen error [Errno 8] nodename nor servname provided, or not known>\n\n/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/urllib2.py:1184: URLError"}, {"jobs": ["marketplace.stage.saucelabs"], "result": "failure", "detail": "test failure: self = <tests.desktop.consumer_pages.test_details_page.TestDetailsPage instance at 0x10a5e6e60>\nmozwebqa = <pytest_mozwebqa.pytest_mozwebqa.TestSetup instance at 0x10a5e6098>\n\n    @pytest.mark.credentials\n    def test_that_reports_abuse_as_signed_in_user(self, mozwebqa):\n    \n        home_page = Home(mozwebqa)\n        home_page.go_to_homepage()\n    \n        Assert.true(home_page.is_the_current_page)\n>       home_page.login(user=\"default\")\n\ntests/desktop/consumer_pages/test_details_page.py:96: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <pages.desktop.consumer_pages.home.Home object at 0x10a41bb10>\nuser = 'default'\n\n    def login(self, user=None):\n>       credentials = isinstance(user, MockUser) and user or self.testsetup.credentials.get(user, PersonaTestUser().create_user())\n\npages/desktop/consumer_pages/base.py:40: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <persona_test_user.PersonaTestUser instance at 0x10a403290>\n\n    def create_user(self):\n        url = \"http://personatestuser.org/email/\"\n>       response = urllib2.urlopen(url).read()\n\npersona_test_user.py:17: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nurl = 'http://personatestuser.org/email/', data = None\ntimeout = <object object at 0x10831d1e0>\n\n    def urlopen(url, data=None, timeout=socket._GLOBAL_DEFAULT_TIMEOUT):\n        global _opener\n        if _opener is None:\n            _opener = build_opener()\n>       return _opener.open(url, data, timeout)\n\n/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/urllib2.py:127: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <urllib2.OpenerDirector instance at 0x10a406ef0>\nfullurl = 'http://personatestuser.org/email/', data = None\ntimeout = <object object at 0x10831d1e0>\n\n    def open(self, fullurl, data=None, timeout=socket._GLOBAL_DEFAULT_TIMEOUT):\n        # accept a URL or a Request object\n        if isinstance(fullurl, basestring):\n            req = Request(fullurl, data)\n        else:\n            req = fullurl\n            if data is not None:\n                req.add_data(data)\n    \n        req.timeout = timeout\n        protocol = req.get_type()\n    \n        # pre-process request\n        meth_name = protocol+\"_request\"\n        for processor in self.process_request.get(protocol, []):\n            meth = getattr(processor, meth_name)\n            req = meth(req)\n    \n>       response = self._open(req, data)\n\n/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/urllib2.py:404: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <urllib2.OpenerDirector instance at 0x10a406ef0>\nreq = <urllib2.Request instance at 0x10a42e200>, data = None\n\n    def _open(self, req, data=None):\n        result = self._call_chain(self.handle_open, 'default',\n                                  'default_open', req)\n        if result:\n            return result\n    \n        protocol = req.get_type()\n        result = self._call_chain(self.handle_open, protocol, protocol +\n>                                 '_open', req)\n\n/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/urllib2.py:422: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <urllib2.OpenerDirector instance at 0x10a406ef0>\nchain = {'file': [<urllib2.FileHandler instance at 0x10a4083b0>], 'ftp': [<urllib2.FTPHandler instance at 0x10a408320>], 'http': [<urllib2.HTTPHandler instance at 0x10a408050>], 'https': [<urllib2.HTTPSHandler instance at 0x10a408518>], ...}\nkind = 'http', meth_name = 'http_open'\nargs = (<urllib2.Request instance at 0x10a42e200>,)\nhandlers = [<urllib2.HTTPHandler instance at 0x10a408050>]\nhandler = <urllib2.HTTPHandler instance at 0x10a408050>\nfunc = <bound method HTTPHandler.http_open of <urllib2.HTTPHandler instance at 0x10a408050>>\n\n    def _call_chain(self, chain, kind, meth_name, *args):\n        # Handlers raise an exception if no one else should try to handle\n        # the request, or return None if they can't but another handler\n        # could.  Otherwise, they return the response.\n        handlers = chain.get(kind, ())\n        for handler in handlers:\n            func = getattr(handler, meth_name)\n    \n>           result = func(*args)\n\n/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/urllib2.py:382: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <urllib2.HTTPHandler instance at 0x10a408050>\nreq = <urllib2.Request instance at 0x10a42e200>\n\n    def http_open(self, req):\n>       return self.do_open(httplib.HTTPConnection, req)\n\n/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/urllib2.py:1214: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <urllib2.HTTPHandler instance at 0x10a408050>\nhttp_class = <class httplib.HTTPConnection at 0x108d91668>\nreq = <urllib2.Request instance at 0x10a42e200>\n\n    def do_open(self, http_class, req):\n        \"\"\"Return an addinfourl object for the request, using http_class.\n    \n            http_class must implement the HTTPConnection API from httplib.\n            The addinfourl return value is a file-like object.  It also\n            has methods and attributes including:\n                - info(): return a mimetools.Message object for the headers\n                - geturl(): return the original request URL\n                - code: HTTP status code\n            \"\"\"\n        host = req.get_host()\n        if not host:\n            raise URLError('no host given')\n    \n        h = http_class(host, timeout=req.timeout) # will parse host:port\n        h.set_debuglevel(self._debuglevel)\n    \n        headers = dict(req.unredirected_hdrs)\n        headers.update(dict((k, v) for k, v in req.headers.items()\n                            if k not in headers))\n    \n        # We want to make an HTTP/1.1 request, but the addinfourl\n        # class isn't prepared to deal with a persistent connection.\n        # It will try to read all remaining data from the socket,\n        # which will block while the server waits for the next request.\n        # So make sure the connection gets closed after the (only)\n        # request.\n        headers[\"Connection\"] = \"close\"\n        headers = dict(\n            (name.title(), val) for name, val in headers.items())\n    \n        if req._tunnel_host:\n            tunnel_headers = {}\n            proxy_auth_hdr = \"Proxy-Authorization\"\n            if proxy_auth_hdr in headers:\n                tunnel_headers[proxy_auth_hdr] = headers[proxy_auth_hdr]\n                # Proxy-Authorization should not be sent to origin\n                # server.\n                del headers[proxy_auth_hdr]\n            h.set_tunnel(req._tunnel_host, headers=tunnel_headers)\n    \n        try:\n            h.request(req.get_method(), req.get_selector(), req.data, headers)\n        except socket.error, err: # XXX what error?\n            h.close()\n>           raise URLError(err)\nE           URLError: <urlopen error [Errno 8] nodename nor servname provided, or not known>\n\n/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/urllib2.py:1184: URLError"}], "passed": [], "test_name": "test_that_reports_abuse_as_signed_in_user"}, {"skipped": {}, "all_passed": true, "environments": ["stage", "dev"], "path_to_result": "tests.desktop.developer_hub.test_developer_hub/TestDeveloperHub/test_that_an_icon_cannot_be_added_via_an_invalid_file_format/", "failed": [], "passed": ["marketplace.stage.developer_hub.saucelabs", "marketplace.dev.developer_hub", "marketplace.dev.developer_hub.saucelabs"], "test_name": "test_that_an_icon_cannot_be_added_via_an_invalid_file_format"}, {"skipped": {}, "all_passed": false, "environments": ["dev", "stage"], "path_to_result": "tests.desktop.consumer_pages.test_reviews/TestReviews/test_that_checks_the_addition_of_a_review/", "failed": [{"jobs": ["marketplace.dev.saucelabs"], "result": "failure", "detail": "test failure: self = <tests.desktop.consumer_pages.test_reviews.TestReviews instance at 0x10ad57128>\nmozwebqa = <pytest_mozwebqa.pytest_mozwebqa.TestSetup instance at 0x10ad94fc8>\n\n    @pytest.mark.credentials\n    def test_that_checks_the_addition_of_a_review(self, mozwebqa):\n        self._reviews_setup(mozwebqa)\n    \n        # delete the review before getting started\n        self.mk_api.delete_app_review(self.review_id)\n    \n        # so that teardown does not try to delete the review\n        del self.review_id\n    \n        # Step 1 - Login into Marketplace\n        mock_review = MockReview()\n        home_page = Home(mozwebqa)\n        home_page.go_to_homepage()\n    \n>       home_page.login(user=\"default\")\n\ntests/desktop/consumer_pages/test_reviews.py:48: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <pages.desktop.consumer_pages.home.Home object at 0x10ad9e150>\nuser = 'default'\n\n    def login(self, user=None):\n>       credentials = isinstance(user, MockUser) and user or self.testsetup.credentials.get(user, PersonaTestUser().create_user())\n\npages/desktop/consumer_pages/base.py:40: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <persona_test_user.PersonaTestUser instance at 0x10bf51f38>\n\n    def create_user(self):\n        url = \"http://personatestuser.org/email/\"\n>       response = urllib2.urlopen(url).read()\n\npersona_test_user.py:17: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nurl = 'http://personatestuser.org/email/', data = None\ntimeout = <object object at 0x109c9f1e0>\n\n    def urlopen(url, data=None, timeout=socket._GLOBAL_DEFAULT_TIMEOUT):\n        global _opener\n        if _opener is None:\n            _opener = build_opener()\n>       return _opener.open(url, data, timeout)\n\n/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/urllib2.py:127: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <urllib2.OpenerDirector instance at 0x10ad7a7a0>\nfullurl = 'http://personatestuser.org/email/', data = None\ntimeout = <object object at 0x109c9f1e0>\n\n    def open(self, fullurl, data=None, timeout=socket._GLOBAL_DEFAULT_TIMEOUT):\n        # accept a URL or a Request object\n        if isinstance(fullurl, basestring):\n            req = Request(fullurl, data)\n        else:\n            req = fullurl\n            if data is not None:\n                req.add_data(data)\n    \n        req.timeout = timeout\n        protocol = req.get_type()\n    \n        # pre-process request\n        meth_name = protocol+\"_request\"\n        for processor in self.process_request.get(protocol, []):\n            meth = getattr(processor, meth_name)\n            req = meth(req)\n    \n>       response = self._open(req, data)\n\n/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/urllib2.py:404: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <urllib2.OpenerDirector instance at 0x10ad7a7a0>\nreq = <urllib2.Request instance at 0x10ad20830>, data = None\n\n    def _open(self, req, data=None):\n        result = self._call_chain(self.handle_open, 'default',\n                                  'default_open', req)\n        if result:\n            return result\n    \n        protocol = req.get_type()\n        result = self._call_chain(self.handle_open, protocol, protocol +\n>                                 '_open', req)\n\n/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/urllib2.py:422: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <urllib2.OpenerDirector instance at 0x10ad7a7a0>\nchain = {'file': [<urllib2.FileHandler instance at 0x10ad7ab90>], 'ftp': [<urllib2.FTPHandler instance at 0x10ad7ab00>], 'http': [<urllib2.HTTPHandler instance at 0x10ad7a830>], 'https': [<urllib2.HTTPSHandler instance at 0x10ad7acf8>], ...}\nkind = 'http', meth_name = 'http_open'\nargs = (<urllib2.Request instance at 0x10ad20830>,)\nhandlers = [<urllib2.HTTPHandler instance at 0x10ad7a830>]\nhandler = <urllib2.HTTPHandler instance at 0x10ad7a830>\nfunc = <bound method HTTPHandler.http_open of <urllib2.HTTPHandler instance at 0x10ad7a830>>\n\n    def _call_chain(self, chain, kind, meth_name, *args):\n        # Handlers raise an exception if no one else should try to handle\n        # the request, or return None if they can't but another handler\n        # could.  Otherwise, they return the response.\n        handlers = chain.get(kind, ())\n        for handler in handlers:\n            func = getattr(handler, meth_name)\n    \n>           result = func(*args)\n\n/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/urllib2.py:382: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <urllib2.HTTPHandler instance at 0x10ad7a830>\nreq = <urllib2.Request instance at 0x10ad20830>\n\n    def http_open(self, req):\n>       return self.do_open(httplib.HTTPConnection, req)\n\n/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/urllib2.py:1214: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <urllib2.HTTPHandler instance at 0x10ad7a830>\nhttp_class = <class httplib.HTTPConnection at 0x10a710870>\nreq = <urllib2.Request instance at 0x10ad20830>\n\n    def do_open(self, http_class, req):\n        \"\"\"Return an addinfourl object for the request, using http_class.\n    \n            http_class must implement the HTTPConnection API from httplib.\n            The addinfourl return value is a file-like object.  It also\n            has methods and attributes including:\n                - info(): return a mimetools.Message object for the headers\n                - geturl(): return the original request URL\n                - code: HTTP status code\n            \"\"\"\n        host = req.get_host()\n        if not host:\n            raise URLError('no host given')\n    \n        h = http_class(host, timeout=req.timeout) # will parse host:port\n        h.set_debuglevel(self._debuglevel)\n    \n        headers = dict(req.unredirected_hdrs)\n        headers.update(dict((k, v) for k, v in req.headers.items()\n                            if k not in headers))\n    \n        # We want to make an HTTP/1.1 request, but the addinfourl\n        # class isn't prepared to deal with a persistent connection.\n        # It will try to read all remaining data from the socket,\n        # which will block while the server waits for the next request.\n        # So make sure the connection gets closed after the (only)\n        # request.\n        headers[\"Connection\"] = \"close\"\n        headers = dict(\n            (name.title(), val) for name, val in headers.items())\n    \n        if req._tunnel_host:\n            tunnel_headers = {}\n            proxy_auth_hdr = \"Proxy-Authorization\"\n            if proxy_auth_hdr in headers:\n                tunnel_headers[proxy_auth_hdr] = headers[proxy_auth_hdr]\n                # Proxy-Authorization should not be sent to origin\n                # server.\n                del headers[proxy_auth_hdr]\n            h.set_tunnel(req._tunnel_host, headers=tunnel_headers)\n    \n        try:\n            h.request(req.get_method(), req.get_selector(), req.data, headers)\n        except socket.error, err: # XXX what error?\n            h.close()\n>           raise URLError(err)\nE           URLError: <urlopen error [Errno 8] nodename nor servname provided, or not known>\n\n/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/urllib2.py:1184: URLError"}, {"jobs": ["marketplace.stage.saucelabs"], "result": "failure", "detail": "test failure: self = <tests.desktop.consumer_pages.test_reviews.TestReviews instance at 0x102844050>\nmozwebqa = <pytest_mozwebqa.pytest_mozwebqa.TestSetup instance at 0x102844f38>\n\n    @pytest.mark.credentials\n    def test_that_checks_the_addition_of_a_review(self, mozwebqa):\n        self._reviews_setup(mozwebqa)\n    \n        # delete the review before getting started\n        self.mk_api.delete_app_review(self.review_id)\n    \n        # so that teardown does not try to delete the review\n        del self.review_id\n    \n        # Step 1 - Login into Marketplace\n        mock_review = MockReview()\n        home_page = Home(mozwebqa)\n        home_page.go_to_homepage()\n    \n>       home_page.login(user=\"default\")\n\ntests/desktop/consumer_pages/test_reviews.py:48: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <pages.desktop.consumer_pages.home.Home object at 0x101786710>\nuser = 'default'\n\n    def login(self, user=None):\n>       credentials = isinstance(user, MockUser) and user or self.testsetup.credentials.get(user, PersonaTestUser().create_user())\n\npages/desktop/consumer_pages/base.py:40: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <persona_test_user.PersonaTestUser instance at 0x10282dbd8>\n\n    def create_user(self):\n        url = \"http://personatestuser.org/email/\"\n>       response = urllib2.urlopen(url).read()\n\npersona_test_user.py:17: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nurl = 'http://personatestuser.org/email/', data = None\ntimeout = <object object at 0x10074b1e0>\n\n    def urlopen(url, data=None, timeout=socket._GLOBAL_DEFAULT_TIMEOUT):\n        global _opener\n        if _opener is None:\n            _opener = build_opener()\n>       return _opener.open(url, data, timeout)\n\n/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/urllib2.py:127: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <urllib2.OpenerDirector instance at 0x10282b128>\nfullurl = 'http://personatestuser.org/email/', data = None\ntimeout = <object object at 0x10074b1e0>\n\n    def open(self, fullurl, data=None, timeout=socket._GLOBAL_DEFAULT_TIMEOUT):\n        # accept a URL or a Request object\n        if isinstance(fullurl, basestring):\n            req = Request(fullurl, data)\n        else:\n            req = fullurl\n            if data is not None:\n                req.add_data(data)\n    \n        req.timeout = timeout\n        protocol = req.get_type()\n    \n        # pre-process request\n        meth_name = protocol+\"_request\"\n        for processor in self.process_request.get(protocol, []):\n            meth = getattr(processor, meth_name)\n            req = meth(req)\n    \n>       response = self._open(req, data)\n\n/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/urllib2.py:404: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <urllib2.OpenerDirector instance at 0x10282b128>\nreq = <urllib2.Request instance at 0x1017fc320>, data = None\n\n    def _open(self, req, data=None):\n        result = self._call_chain(self.handle_open, 'default',\n                                  'default_open', req)\n        if result:\n            return result\n    \n        protocol = req.get_type()\n        result = self._call_chain(self.handle_open, protocol, protocol +\n>                                 '_open', req)\n\n/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/urllib2.py:422: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <urllib2.OpenerDirector instance at 0x10282b128>\nchain = {'file': [<urllib2.FileHandler instance at 0x10282b518>], 'ftp': [<urllib2.FTPHandler instance at 0x10282b488>], 'http': [<urllib2.HTTPHandler instance at 0x10282b1b8>], 'https': [<urllib2.HTTPSHandler instance at 0x10282b680>], ...}\nkind = 'http', meth_name = 'http_open'\nargs = (<urllib2.Request instance at 0x1017fc320>,)\nhandlers = [<urllib2.HTTPHandler instance at 0x10282b1b8>]\nhandler = <urllib2.HTTPHandler instance at 0x10282b1b8>\nfunc = <bound method HTTPHandler.http_open of <urllib2.HTTPHandler instance at 0x10282b1b8>>\n\n    def _call_chain(self, chain, kind, meth_name, *args):\n        # Handlers raise an exception if no one else should try to handle\n        # the request, or return None if they can't but another handler\n        # could.  Otherwise, they return the response.\n        handlers = chain.get(kind, ())\n        for handler in handlers:\n            func = getattr(handler, meth_name)\n    \n>           result = func(*args)\n\n/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/urllib2.py:382: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <urllib2.HTTPHandler instance at 0x10282b1b8>\nreq = <urllib2.Request instance at 0x1017fc320>\n\n    def http_open(self, req):\n>       return self.do_open(httplib.HTTPConnection, req)\n\n/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/urllib2.py:1214: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <urllib2.HTTPHandler instance at 0x10282b1b8>\nhttp_class = <class httplib.HTTPConnection at 0x1011bf668>\nreq = <urllib2.Request instance at 0x1017fc320>\n\n    def do_open(self, http_class, req):\n        \"\"\"Return an addinfourl object for the request, using http_class.\n    \n            http_class must implement the HTTPConnection API from httplib.\n            The addinfourl return value is a file-like object.  It also\n            has methods and attributes including:\n                - info(): return a mimetools.Message object for the headers\n                - geturl(): return the original request URL\n                - code: HTTP status code\n            \"\"\"\n        host = req.get_host()\n        if not host:\n            raise URLError('no host given')\n    \n        h = http_class(host, timeout=req.timeout) # will parse host:port\n        h.set_debuglevel(self._debuglevel)\n    \n        headers = dict(req.unredirected_hdrs)\n        headers.update(dict((k, v) for k, v in req.headers.items()\n                            if k not in headers))\n    \n        # We want to make an HTTP/1.1 request, but the addinfourl\n        # class isn't prepared to deal with a persistent connection.\n        # It will try to read all remaining data from the socket,\n        # which will block while the server waits for the next request.\n        # So make sure the connection gets closed after the (only)\n        # request.\n        headers[\"Connection\"] = \"close\"\n        headers = dict(\n            (name.title(), val) for name, val in headers.items())\n    \n        if req._tunnel_host:\n            tunnel_headers = {}\n            proxy_auth_hdr = \"Proxy-Authorization\"\n            if proxy_auth_hdr in headers:\n                tunnel_headers[proxy_auth_hdr] = headers[proxy_auth_hdr]\n                # Proxy-Authorization should not be sent to origin\n                # server.\n                del headers[proxy_auth_hdr]\n            h.set_tunnel(req._tunnel_host, headers=tunnel_headers)\n    \n        try:\n            h.request(req.get_method(), req.get_selector(), req.data, headers)\n        except socket.error, err: # XXX what error?\n            h.close()\n>           raise URLError(err)\nE           URLError: <urlopen error [Errno 8] nodename nor servname provided, or not known>\n\n/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/urllib2.py:1184: URLError"}], "passed": [], "test_name": "test_that_checks_the_addition_of_a_review"}, {"skipped": {}, "all_passed": true, "environments": ["stage", "dev"], "path_to_result": "tests.desktop.developer_hub.test_developer_hub_submit_apps/TestDeveloperHubSubmitApps/test_packaged_app_submission/", "failed": [], "passed": ["marketplace.stage.developer_hub.saucelabs", "marketplace.dev.developer_hub", "marketplace.dev.developer_hub.saucelabs"], "test_name": "test_packaged_app_submission"}, {"skipped": {}, "all_passed": true, "environments": ["stage", "dev"], "path_to_result": "tests.desktop.developer_hub.test_developer_hub_submit_apps/TestDeveloperHubSubmitApps/test_hosted_paid_app_submission/", "failed": [], "passed": ["marketplace.stage.developer_hub.saucelabs", "marketplace.dev.developer_hub", "marketplace.dev.developer_hub.saucelabs"], "test_name": "test_hosted_paid_app_submission"}, {"skipped": {}, "all_passed": true, "environments": ["dev", "prod", "stage"], "path_to_result": "tests.desktop.consumer_pages.test_consumers_page/TestConsumerPage/test_that_verifies_featured_application_section/", "failed": [], "passed": ["marketplace.dev.saucelabs", "marketplace.prod", "marketplace.stage.saucelabs", "marketplace.prod.saucelabs"], "test_name": "test_that_verifies_featured_application_section"}, {"skipped": {}, "all_passed": true, "environments": ["stage", "dev"], "path_to_result": "tests.desktop.developer_hub.test_developer_hub/TestDeveloperHub/test_that_checks_apps_are_sorted_by_name/", "failed": [], "passed": ["marketplace.stage.developer_hub.saucelabs", "marketplace.dev.developer_hub", "marketplace.dev.developer_hub.saucelabs"], "test_name": "test_that_checks_apps_are_sorted_by_name"}, {"skipped": {}, "all_passed": true, "environments": ["dev", "prod", "stage"], "path_to_result": "tests.desktop.consumer_pages.test_consumers_page/TestConsumerPage/test_that_verifies_gallery_section_tabs/", "failed": [], "passed": ["marketplace.dev.saucelabs", "marketplace.prod", "marketplace.stage.saucelabs", "marketplace.prod.saucelabs"], "test_name": "test_that_verifies_gallery_section_tabs"}, {"skipped": {"jobs": ["marketplace.dev.saucelabs", "marketplace.prod", "marketplace.stage.saucelabs", "marketplace.prod.saucelabs"], "result": "skipped", "detail": "Search suggestions not available yet.: /Users/Shared/Jenkins/Home/jobs/marketplace.dev.saucelabs/workspace/.env/lib/python2.7/site-packages/_pytest/skipping.py:120: Skipped: Search suggestions not available yet."}, "all_passed": true, "environments": ["dev", "prod", "stage"], "path_to_result": "tests.desktop.consumer_pages.test_search/TestSearching/test_that_verifies_the_search_suggestions_list_under_the_search_field/", "failed": [], "passed": [], "test_name": "test_that_verifies_the_search_suggestions_list_under_the_search_field"}, {"skipped": {"jobs": ["marketplace.dev.saucelabs", "marketplace.prod", "marketplace.stage.saucelabs", "marketplace.prod.saucelabs"], "result": "skipped", "detail": "Sort not available yet.: /Users/Shared/Jenkins/Home/jobs/marketplace.dev.saucelabs/workspace/.env/lib/python2.7/site-packages/_pytest/skipping.py:120: Skipped: Sort not available yet."}, "all_passed": true, "environments": ["dev", "prod", "stage"], "path_to_result": "tests.desktop.consumer_pages.test_search/TestSearching/test_that_verifies_the_sort_region_from_search_results[Relevancy]/", "failed": [], "passed": [], "test_name": "test_that_verifies_the_sort_region_from_search_results[Relevancy]"}]}]}